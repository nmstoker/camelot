{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Camelot is a Python library that can help you extract tables from PDFs</p> <p>Here's how you can extract tables from PDFs. You can check out the PDF used in this example here.</p> <pre><code>&gt;&gt;&gt; import camelot\n&gt;&gt;&gt; tables = camelot.read_pdf('foo.pdf')\n&gt;&gt;&gt; tables\n&lt;TableList n=1&gt;\n&gt;&gt;&gt; tables.export('foo.csv', f='csv', compress=True) # json, excel, html, markdown, sqlite\n&gt;&gt;&gt; tables[0]\n&lt;Table shape=(7, 7)&gt;\n&gt;&gt;&gt; tables[0].parsing_report\n{\n    'accuracy': 99.02,\n    'whitespace': 12.24,\n    'order': 1,\n    'page': 1\n}\n&gt;&gt;&gt; tables[0].to_csv('foo.csv') # to_json, to_excel, to_html, to_markdown, to_sqlite\n&gt;&gt;&gt; tables[0].df # get a pandas DataFrame!\n</code></pre> Cycle Name KI (1/km) Distance (mi) Percent Fuel Savings Unnamed: 4 Unnamed: 5 Unnamed: 6 nan nan nan Improved Speed Decreased Accel Eliminate Stops Decreased Idle 20122 3.3 1.3 5.9% 9.5% 29.2% 17.4% 21451 0.68 11.2 2.4% 0.1% 9.5% 2.7% 42341 0.59 58.7 8.5% 1.3% 8.5% 3.3% 20322 0.17 57.8 21.7% 0.3% 2.7% 1.2% 41711 0.07 173.9 58.1% 1.6% 2.1% 0.5% <p>Camelot also comes packaged with a command-line interface</p> <p>Note</p> <p>Camelot only works with text-based PDFs and not scanned documents. As Tabula explains, \"If you can click and drag to select text in your table in a PDF viewer, then your PDF is text-based\".</p> <p>You can check out some frequently asked questions here.</p>"},{"location":"#why-camelot","title":"Why Camelot?","text":"<ul> <li>Configurability: Camelot gives you control over the table extraction process with tweakable settings.</li> <li>Metrics: You can discard bad tables based on metrics like accuracy and whitespace, without having to manually look at each table.</li> <li> <p>Output: Each table is extracted into a pandas DataFrame, which seamlessly integrates into ETL and data analysis workflows. You can also export tables to multiple formats, which include CSV, JSON, Excel, HTML, Markdown, and Sqlite.</p> </li> <li> <p>ETL and data analysis workflows: see example notebook here</p> </li> </ul> <p>See comparison with similar libraries and tools.</p>"},{"location":"#support-the-development","title":"Support the development","text":"<p>If Camelot has helped you, please consider supporting its development with a one-time or monthly donation on OpenCollective.</p>"},{"location":"#user-guide","title":"User Guide","text":"<p>This part of the documentation begins with some background information about why Camelot was created, takes you through some implementation details, and then focuses on step-by-step instructions for getting the most out of Camelot.</p> <p>User Guide</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>If you are looking for information on a specific function, class, or method, this part of the documentation is for you.</p> <p>API Reference</p>"},{"location":"#contributor-guide","title":"Contributor Guide","text":"<p>If you want to contribute to the project, this part of the documentation is for you.</p> <p>Contributor Guide</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#main-interface","title":"Main Interface","text":""},{"location":"api/#camelot.io.read_pdf","title":"camelot.io.read_pdf","text":"<pre><code>read_pdf(\n    filepath,\n    pages=\"1\",\n    password=None,\n    flavor=\"lattice\",\n    suppress_stdout=False,\n    layout_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Read PDF and return extracted tables.</p> <p>Note: kwargs annotated with ^ can only be used with flavor='stream' and kwargs annotated with * can only be used with flavor='lattice'.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>(str, Path, IO)</code> <p>Filepath or URL of the PDF file.</p> required <code>pages</code> <code>str, optional (default: '1')</code> <p>Comma-separated page numbers. Example: '1,3,4' or '1,4-end' or 'all'.</p> <code>'1'</code> <code>password</code> <code>str, optional (default: None)</code> <p>Password for decryption.</p> <code>None</code> <code>flavor</code> <code>str (default: 'lattice')</code> <p>The parsing method to use ('lattice' or 'stream'). Lattice is used by default.</p> <code>'lattice'</code> <code>suppress_stdout</code> <code>bool, optional (default: True)</code> <p>Print all logs and warnings.</p> <code>False</code> <code>layout_kwargs</code> <code>dict, optional (default: {})</code> <p>A dict of <code>pdfminer.layout.LAParams &lt;https://github.com/euske/pdfminer/blob/master/pdfminer/layout.py#L33&gt;</code>_ kwargs.</p> <code>None</code> <code>table_areas</code> <code>list, optional (default: None)</code> <p>List of table area strings of the form x1,y1,x2,y2 where (x1, y1) -&gt; left-top and (x2, y2) -&gt; right-bottom in PDF coordinate space.</p> required <code>columns</code> <p>List of column x-coordinates strings where the coordinates are comma-separated.</p> required <code>split_text</code> <code>bool, optional (default: False)</code> <p>Split text that spans across multiple cells.</p> required <code>flag_size</code> <code>bool, optional (default: False)</code> <p>Flag text based on font size. Useful to detect super/subscripts. Adds  around flagged text.</p> required <code>strip_text</code> <code>str, optional (default: '')</code> <p>Characters that should be stripped from a string before assigning it to a cell.</p> required <code>row_tol</code> <p>Tolerance parameter used to combine text vertically, to generate rows.</p> required <code>column_tol</code> <p>Tolerance parameter used to combine text horizontally, to generate columns.</p> required <code>process_background</code> <p>Process background lines.</p> required <code>line_scale</code> <p>Line size scaling factor. The larger the value the smaller the detected lines. Making it very large will lead to text being detected as lines.</p> required <code>copy_text</code> <p>{'h', 'v'} Direction in which text in a spanning cell will be copied over.</p> required <code>shift_text</code> <p>{'l', 'r', 't', 'b'} Direction in which text in a spanning cell will flow.</p> required <code>line_tol</code> <p>Tolerance parameter used to merge close vertical and horizontal lines.</p> required <code>joint_tol</code> <p>Tolerance parameter used to decide whether the detected lines and points lie close to each other.</p> required <code>threshold_blocksize</code> <p>Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.</p> <p>For more information, refer <code>OpenCV's adaptiveThreshold &lt;https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#adaptivethreshold&gt;</code>_.</p> required <code>threshold_constant</code> <p>Constant subtracted from the mean or weighted mean. Normally, it is positive but may be zero or negative as well.</p> <p>For more information, refer <code>OpenCV's adaptiveThreshold &lt;https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#adaptivethreshold&gt;</code>_.</p> required <code>iterations</code> <p>Number of times for erosion/dilation is applied.</p> <p>For more information, refer <code>OpenCV's dilate &lt;https://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html#dilate&gt;</code>_.</p> required <code>resolution</code> <p>Resolution used for PDF to PNG conversion.</p> required <p>Returns:</p> Name Type Description <code>tables</code> <code>TableList</code> Source code in <code>camelot/io.py</code> <pre><code>def read_pdf(\n    filepath: Union[StrByteType, Path],\n    pages=\"1\",\n    password=None,\n    flavor=\"lattice\",\n    suppress_stdout=False,\n    layout_kwargs=None,\n    **kwargs\n):\n    \"\"\"Read PDF and return extracted tables.\n\n    Note: kwargs annotated with ^ can only be used with flavor='stream'\n    and kwargs annotated with * can only be used with flavor='lattice'.\n\n    Parameters\n    ----------\n    filepath : str, Path, IO\n        Filepath or URL of the PDF file.\n    pages : str, optional (default: '1')\n        Comma-separated page numbers.\n        Example: '1,3,4' or '1,4-end' or 'all'.\n    password : str, optional (default: None)\n        Password for decryption.\n    flavor : str (default: 'lattice')\n        The parsing method to use ('lattice' or 'stream').\n        Lattice is used by default.\n    suppress_stdout : bool, optional (default: True)\n        Print all logs and warnings.\n    layout_kwargs : dict, optional (default: {})\n        A dict of `pdfminer.layout.LAParams\n        &lt;https://github.com/euske/pdfminer/blob/master/pdfminer/layout.py#L33&gt;`_ kwargs.\n    table_areas : list, optional (default: None)\n        List of table area strings of the form x1,y1,x2,y2\n        where (x1, y1) -&gt; left-top and (x2, y2) -&gt; right-bottom\n        in PDF coordinate space.\n    columns^ : list, optional (default: None)\n        List of column x-coordinates strings where the coordinates\n        are comma-separated.\n    split_text : bool, optional (default: False)\n        Split text that spans across multiple cells.\n    flag_size : bool, optional (default: False)\n        Flag text based on font size. Useful to detect\n        super/subscripts. Adds &lt;s&gt;&lt;/s&gt; around flagged text.\n    strip_text : str, optional (default: '')\n        Characters that should be stripped from a string before\n        assigning it to a cell.\n    row_tol^ : int, optional (default: 2)\n        Tolerance parameter used to combine text vertically,\n        to generate rows.\n    column_tol^ : int, optional (default: 0)\n        Tolerance parameter used to combine text horizontally,\n        to generate columns.\n    process_background* : bool, optional (default: False)\n        Process background lines.\n    line_scale* : int, optional (default: 15)\n        Line size scaling factor. The larger the value the smaller\n        the detected lines. Making it very large will lead to text\n        being detected as lines.\n    copy_text* : list, optional (default: None)\n        {'h', 'v'}\n        Direction in which text in a spanning cell will be copied\n        over.\n    shift_text* : list, optional (default: ['l', 't'])\n        {'l', 'r', 't', 'b'}\n        Direction in which text in a spanning cell will flow.\n    line_tol* : int, optional (default: 2)\n        Tolerance parameter used to merge close vertical and horizontal\n        lines.\n    joint_tol* : int, optional (default: 2)\n        Tolerance parameter used to decide whether the detected lines\n        and points lie close to each other.\n    threshold_blocksize* : int, optional (default: 15)\n        Size of a pixel neighborhood that is used to calculate a\n        threshold value for the pixel: 3, 5, 7, and so on.\n\n        For more information, refer `OpenCV's adaptiveThreshold\n        &lt;https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#adaptivethreshold&gt;`_.\n    threshold_constant* : int, optional (default: -2)\n        Constant subtracted from the mean or weighted mean.\n        Normally, it is positive but may be zero or negative as well.\n\n        For more information, refer `OpenCV's adaptiveThreshold\n        &lt;https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#adaptivethreshold&gt;`_.\n    iterations* : int, optional (default: 0)\n        Number of times for erosion/dilation is applied.\n\n        For more information, refer `OpenCV's dilate\n        &lt;https://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html#dilate&gt;`_.\n    resolution* : int, optional (default: 300)\n        Resolution used for PDF to PNG conversion.\n\n    Returns\n    -------\n    tables : camelot.core.TableList\n\n    \"\"\"\n    if layout_kwargs is None:\n        layout_kwargs = {}\n    if flavor not in [\"lattice\", \"stream\"]:\n        raise NotImplementedError(\n            \"Unknown flavor specified.\" \" Use either 'lattice' or 'stream'\"\n        )\n\n    with warnings.catch_warnings():\n        if suppress_stdout:\n            warnings.simplefilter(\"ignore\")\n\n        validate_input(kwargs, flavor=flavor)\n        p = PDFHandler(filepath, pages=pages, password=password)\n        kwargs = remove_extra(kwargs, flavor=flavor)\n        tables = p.parse(\n            flavor=flavor,\n            suppress_stdout=suppress_stdout,\n            layout_kwargs=layout_kwargs,\n            **kwargs\n        )\n        return tables\n</code></pre>"},{"location":"api/#general-classes","title":"General Classes","text":""},{"location":"api/#camelot.handlers.PDFHandler","title":"camelot.handlers.PDFHandler","text":"<p>Handles all operations like temp directory creation, splitting file into single page PDFs, parsing each PDF and then removing the temp directory.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Filepath or URL of the PDF file.</p> required <code>pages</code> <code>str, optional (default: '1')</code> <p>Comma-separated page numbers. Example: '1,3,4' or '1,4-end' or 'all'.</p> <code>'1'</code> <code>password</code> <code>str, optional (default: None)</code> <p>Password for decryption.</p> <code>None</code> Source code in <code>camelot/handlers.py</code> <pre><code>class PDFHandler:\n    \"\"\"Handles all operations like temp directory creation, splitting\n    file into single page PDFs, parsing each PDF and then removing the\n    temp directory.\n\n    Parameters\n    ----------\n    filepath : str\n        Filepath or URL of the PDF file.\n    pages : str, optional (default: '1')\n        Comma-separated page numbers.\n        Example: '1,3,4' or '1,4-end' or 'all'.\n    password : str, optional (default: None)\n        Password for decryption.\n\n    \"\"\"\n\n    def __init__(self, filepath: Union[StrByteType, Path], pages=\"1\", password=None):\n        if is_url(filepath):\n            filepath = download_url(filepath)\n        self.filepath: Union[StrByteType, Path] = filepath\n\n        if isinstance(filepath, str) and not filepath.lower().endswith(\".pdf\"):\n            raise NotImplementedError(\"File format not supported\")\n\n        if password is None:\n            self.password = \"\"  # noqa: S105\n        else:\n            self.password = password\n            if sys.version_info[0] &lt; 3:\n                self.password = self.password.encode(\"ascii\")\n        self.pages = self._get_pages(pages)\n\n    def _get_pages(self, pages):\n        \"\"\"Converts pages string to list of ints.\n\n        Parameters\n        ----------\n        filepath : str\n            Filepath or URL of the PDF file.\n        pages : str, optional (default: '1')\n            Comma-separated page numbers.\n            Example: '1,3,4' or '1,4-end' or 'all'.\n\n        Returns\n        -------\n        P : list\n            List of int page numbers.\n\n        \"\"\"\n        page_numbers = []\n\n        if pages == \"1\":\n            page_numbers.append({\"start\": 1, \"end\": 1})\n        else:\n            infile = PdfReader(self.filepath, strict=False)\n\n            if infile.is_encrypted:\n                infile.decrypt(self.password)\n\n            if pages == \"all\":\n                page_numbers.append({\"start\": 1, \"end\": len(infile.pages)})\n            else:\n                for r in pages.split(\",\"):\n                    if \"-\" in r:\n                        a, b = r.split(\"-\")\n                        if b == \"end\":\n                            b = len(infile.pages)\n                        page_numbers.append({\"start\": int(a), \"end\": int(b)})\n                    else:\n                        page_numbers.append({\"start\": int(r), \"end\": int(r)})\n\n        result = []\n        for p in page_numbers:\n            result.extend(range(p[\"start\"], p[\"end\"] + 1))\n        return sorted(set(result))\n\n    def _save_page(self, filepath: Union[StrByteType, Path], page, temp):\n        \"\"\"Saves specified page from PDF into a temporary directory.\n\n        Parameters\n        ----------\n        filepath : str\n            Filepath or URL of the PDF file.\n        page : int\n            Page number.\n        temp : str\n            Tmp directory.\n\n        \"\"\"\n        infile = PdfReader(filepath, strict=False)\n        if infile.is_encrypted:\n            infile.decrypt(self.password)\n        fpath = os.path.join(temp, f\"page-{page}.pdf\")\n        froot, fext = os.path.splitext(fpath)\n        p = infile.pages[page - 1]\n        outfile = PdfWriter()\n        outfile.add_page(p)\n        with open(fpath, \"wb\") as f:\n            outfile.write(f)\n        layout, dim = get_page_layout(fpath)\n        # fix rotated PDF\n        chars = get_text_objects(layout, ltype=\"char\")\n        horizontal_text = get_text_objects(layout, ltype=\"horizontal_text\")\n        vertical_text = get_text_objects(layout, ltype=\"vertical_text\")\n        rotation = get_rotation(chars, horizontal_text, vertical_text)\n        if rotation != \"\":\n            fpath_new = \"\".join([froot.replace(\"page\", \"p\"), \"_rotated\", fext])\n            os.rename(fpath, fpath_new)\n            instream = open(fpath_new, \"rb\")\n            infile = PdfReader(instream, strict=False)\n            if infile.is_encrypted:\n                infile.decrypt(self.password)\n            outfile = PdfWriter()\n            p = infile.pages[0]\n            if rotation == \"anticlockwise\":\n                p.rotate(90)\n            elif rotation == \"clockwise\":\n                p.rotate(-90)\n            outfile.add_page(p)\n            with open(fpath, \"wb\") as f:\n                outfile.write(f)\n            instream.close()\n\n    def parse(\n        self, flavor=\"lattice\", suppress_stdout=False, layout_kwargs=None, **kwargs\n    ):\n        \"\"\"Extracts tables by calling parser.get_tables on all single\n        page PDFs.\n\n        Parameters\n        ----------\n        flavor : str (default: 'lattice')\n            The parsing method to use ('lattice' or 'stream').\n            Lattice is used by default.\n        suppress_stdout : str (default: False)\n            Suppress logs and warnings.\n        layout_kwargs : dict, optional (default: {})\n            A dict of `pdfminer.layout.LAParams\n            &lt;https://github.com/euske/pdfminer/blob/master/pdfminer/layout.py#L33&gt;`_ kwargs.\n        kwargs : dict\n            See camelot.read_pdf kwargs.\n\n        Returns\n        -------\n        tables : camelot.core.TableList\n            List of tables found in PDF.\n\n        \"\"\"\n        if layout_kwargs is None:\n            layout_kwargs = {}\n\n        tables = []\n        with TemporaryDirectory() as tempdir:\n            for p in self.pages:\n                self._save_page(self.filepath, p, tempdir)\n            pages = [os.path.join(tempdir, f\"page-{p}.pdf\") for p in self.pages]\n            parser = Lattice(**kwargs) if flavor == \"lattice\" else Stream(**kwargs)\n            for p in pages:\n                t = parser.extract_tables(\n                    p, suppress_stdout=suppress_stdout, layout_kwargs=layout_kwargs\n                )\n                tables.extend(t)\n        return TableList(sorted(tables))\n</code></pre>"},{"location":"api/#camelot.handlers.PDFHandler.parse","title":"camelot.handlers.PDFHandler.parse","text":"<pre><code>parse(\n    flavor=\"lattice\",\n    suppress_stdout=False,\n    layout_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Extracts tables by calling parser.get_tables on all single page PDFs.</p> <p>Parameters:</p> Name Type Description Default <code>flavor</code> <code>str (default: 'lattice')</code> <p>The parsing method to use ('lattice' or 'stream'). Lattice is used by default.</p> <code>'lattice'</code> <code>suppress_stdout</code> <code>str (default: False)</code> <p>Suppress logs and warnings.</p> <code>False</code> <code>layout_kwargs</code> <code>dict, optional (default: {})</code> <p>A dict of <code>pdfminer.layout.LAParams &lt;https://github.com/euske/pdfminer/blob/master/pdfminer/layout.py#L33&gt;</code>_ kwargs.</p> <code>None</code> <code>kwargs</code> <code>dict</code> <p>See camelot.read_pdf kwargs.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tables</code> <code>TableList</code> <p>List of tables found in PDF.</p> Source code in <code>camelot/handlers.py</code> <pre><code>def parse(\n    self, flavor=\"lattice\", suppress_stdout=False, layout_kwargs=None, **kwargs\n):\n    \"\"\"Extracts tables by calling parser.get_tables on all single\n    page PDFs.\n\n    Parameters\n    ----------\n    flavor : str (default: 'lattice')\n        The parsing method to use ('lattice' or 'stream').\n        Lattice is used by default.\n    suppress_stdout : str (default: False)\n        Suppress logs and warnings.\n    layout_kwargs : dict, optional (default: {})\n        A dict of `pdfminer.layout.LAParams\n        &lt;https://github.com/euske/pdfminer/blob/master/pdfminer/layout.py#L33&gt;`_ kwargs.\n    kwargs : dict\n        See camelot.read_pdf kwargs.\n\n    Returns\n    -------\n    tables : camelot.core.TableList\n        List of tables found in PDF.\n\n    \"\"\"\n    if layout_kwargs is None:\n        layout_kwargs = {}\n\n    tables = []\n    with TemporaryDirectory() as tempdir:\n        for p in self.pages:\n            self._save_page(self.filepath, p, tempdir)\n        pages = [os.path.join(tempdir, f\"page-{p}.pdf\") for p in self.pages]\n        parser = Lattice(**kwargs) if flavor == \"lattice\" else Stream(**kwargs)\n        for p in pages:\n            t = parser.extract_tables(\n                p, suppress_stdout=suppress_stdout, layout_kwargs=layout_kwargs\n            )\n            tables.extend(t)\n    return TableList(sorted(tables))\n</code></pre>"},{"location":"api/#camelot.parsers.Stream","title":"camelot.parsers.Stream","text":"<p>             Bases: <code>BaseParser</code></p> <p>Stream method of parsing looks for spaces between text to parse the table.</p> <p>If you want to specify columns when specifying multiple table areas, make sure that the length of both lists are equal.</p> <p>Parameters:</p> Name Type Description Default <code>table_regions</code> <code>list, optional (default: None)</code> <p>List of page regions that may contain tables of the form x1,y1,x2,y2 where (x1, y1) -&gt; left-top and (x2, y2) -&gt; right-bottom in PDF coordinate space.</p> <code>None</code> <code>table_areas</code> <code>list, optional (default: None)</code> <p>List of table area strings of the form x1,y1,x2,y2 where (x1, y1) -&gt; left-top and (x2, y2) -&gt; right-bottom in PDF coordinate space.</p> <code>None</code> <code>columns</code> <code>list, optional (default: None)</code> <p>List of column x-coordinates strings where the coordinates are comma-separated.</p> <code>None</code> <code>split_text</code> <code>bool, optional (default: False)</code> <p>Split text that spans across multiple cells.</p> <code>False</code> <code>flag_size</code> <code>bool, optional (default: False)</code> <p>Flag text based on font size. Useful to detect super/subscripts. Adds  around flagged text.</p> <code>False</code> <code>strip_text</code> <code>str, optional (default: '')</code> <p>Characters that should be stripped from a string before assigning it to a cell.</p> <code>''</code> <code>edge_tol</code> <code>int, optional (default: 50)</code> <p>Tolerance parameter for extending textedges vertically.</p> <code>50</code> <code>row_tol</code> <code>int, optional (default: 2)</code> <p>Tolerance parameter used to combine text vertically, to generate rows.</p> <code>2</code> <code>column_tol</code> <code>int, optional (default: 0)</code> <p>Tolerance parameter used to combine text horizontally, to generate columns.</p> <code>0</code> Source code in <code>camelot/parsers/stream.py</code> <pre><code>class Stream(BaseParser):\n    \"\"\"Stream method of parsing looks for spaces between text\n    to parse the table.\n\n    If you want to specify columns when specifying multiple table\n    areas, make sure that the length of both lists are equal.\n\n    Parameters\n    ----------\n    table_regions : list, optional (default: None)\n        List of page regions that may contain tables of the form x1,y1,x2,y2\n        where (x1, y1) -&gt; left-top and (x2, y2) -&gt; right-bottom\n        in PDF coordinate space.\n    table_areas : list, optional (default: None)\n        List of table area strings of the form x1,y1,x2,y2\n        where (x1, y1) -&gt; left-top and (x2, y2) -&gt; right-bottom\n        in PDF coordinate space.\n    columns : list, optional (default: None)\n        List of column x-coordinates strings where the coordinates\n        are comma-separated.\n    split_text : bool, optional (default: False)\n        Split text that spans across multiple cells.\n    flag_size : bool, optional (default: False)\n        Flag text based on font size. Useful to detect\n        super/subscripts. Adds &lt;s&gt;&lt;/s&gt; around flagged text.\n    strip_text : str, optional (default: '')\n        Characters that should be stripped from a string before\n        assigning it to a cell.\n    edge_tol : int, optional (default: 50)\n        Tolerance parameter for extending textedges vertically.\n    row_tol : int, optional (default: 2)\n        Tolerance parameter used to combine text vertically,\n        to generate rows.\n    column_tol : int, optional (default: 0)\n        Tolerance parameter used to combine text horizontally,\n        to generate columns.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        table_regions=None,\n        table_areas=None,\n        columns=None,\n        split_text=False,\n        flag_size=False,\n        strip_text=\"\",\n        edge_tol=50,\n        row_tol=2,\n        column_tol=0,\n        **kwargs,\n    ):\n        self.table_regions = table_regions\n        self.table_areas = table_areas\n        self.columns = columns\n        self._validate_columns()\n        self.split_text = split_text\n        self.flag_size = flag_size\n        self.strip_text = strip_text\n        self.edge_tol = edge_tol\n        self.row_tol = row_tol\n        self.column_tol = column_tol\n\n    @staticmethod\n    def _text_bbox(t_bbox):\n        \"\"\"Returns bounding box for the text present on a page.\n\n        Parameters\n        ----------\n        t_bbox : dict\n            Dict with two keys 'horizontal' and 'vertical' with lists of\n            LTTextLineHorizontals and LTTextLineVerticals respectively.\n\n        Returns\n        -------\n        text_bbox : tuple\n            Tuple (x0, y0, x1, y1) in pdf coordinate space.\n\n        \"\"\"\n        xmin = 0\n        ymin = 0\n        xmax = 0\n        ymax = 0\n        if len([t.x0 for direction in t_bbox for t in t_bbox[direction]]) &gt; 0:\n            xmin = min([t.x0 for direction in t_bbox for t in t_bbox[direction]])\n            ymin = min([t.y0 for direction in t_bbox for t in t_bbox[direction]])\n            xmax = max([t.x1 for direction in t_bbox for t in t_bbox[direction]])\n            ymax = max([t.y1 for direction in t_bbox for t in t_bbox[direction]])\n        text_bbox = (xmin, ymin, xmax, ymax)\n        return text_bbox\n\n    @staticmethod\n    def _group_rows(text, row_tol=2):\n        \"\"\"Groups PDFMiner text objects into rows vertically\n        within a tolerance.\n\n        Parameters\n        ----------\n        text : list\n            List of PDFMiner text objects.\n        row_tol : int, optional (default: 2)\n\n        Returns\n        -------\n        rows : list\n            Two-dimensional list of text objects grouped into rows.\n\n        \"\"\"\n        row_y = 0\n        rows = []\n        temp = []\n\n        for t in text:\n            # is checking for upright necessary?\n            # if t.get_text().strip() and all([obj.upright for obj in t._objs if\n            # type(obj) is LTChar]):\n            if t.get_text().strip():\n                if not np.isclose(row_y, t.y0, atol=row_tol):\n                    rows.append(sorted(temp, key=lambda t: t.x0))\n                    temp = []\n                    row_y = t.y0\n                temp.append(t)\n\n        rows.append(sorted(temp, key=lambda t: t.x0))\n        if len(rows) &gt; 1:\n            __ = rows.pop(0)  # TODO: hacky\n        return rows\n\n    @staticmethod\n    def _merge_columns(l, column_tol=0):\n        \"\"\"Merges column boundaries horizontally if they overlap\n        or lie within a tolerance.\n\n        Parameters\n        ----------\n        l : list\n            List of column x-coordinate tuples.\n        column_tol : int, optional (default: 0)\n\n        Returns\n        -------\n        merged : list\n            List of merged column x-coordinate tuples.\n\n        \"\"\"\n        merged = []\n        for higher in l:\n            if not merged:\n                merged.append(higher)\n            else:\n                lower = merged[-1]\n                if column_tol &gt;= 0:\n                    if higher[0] &lt;= lower[1] or np.isclose(\n                        higher[0], lower[1], atol=column_tol\n                    ):\n                        upper_bound = max(lower[1], higher[1])\n                        lower_bound = min(lower[0], higher[0])\n                        merged[-1] = (lower_bound, upper_bound)\n                    else:\n                        merged.append(higher)\n                elif column_tol &lt; 0:\n                    if higher[0] &lt;= lower[1]:\n                        if np.isclose(higher[0], lower[1], atol=abs(column_tol)):\n                            merged.append(higher)\n                        else:\n                            upper_bound = max(lower[1], higher[1])\n                            lower_bound = min(lower[0], higher[0])\n                            merged[-1] = (lower_bound, upper_bound)\n                    else:\n                        merged.append(higher)\n        return merged\n\n    @staticmethod\n    def _join_rows(rows_grouped, text_y_max, text_y_min):\n        \"\"\"Makes row coordinates continuous.\n\n        Parameters\n        ----------\n        rows_grouped : list\n            Two-dimensional list of text objects grouped into rows.\n        text_y_max : int\n        text_y_min : int\n\n        Returns\n        -------\n        rows : list\n            List of continuous row y-coordinate tuples.\n\n        \"\"\"\n        row_mids = [\n            sum([(t.y0 + t.y1) / 2 for t in r]) / len(r) if len(r) &gt; 0 else 0\n            for r in rows_grouped\n        ]\n        rows = [(row_mids[i] + row_mids[i - 1]) / 2 for i in range(1, len(row_mids))]\n        rows.insert(0, text_y_max)\n        rows.append(text_y_min)\n        rows = [(rows[i], rows[i + 1]) for i in range(0, len(rows) - 1)]\n        return rows\n\n    @staticmethod\n    def _add_columns(cols, text, row_tol):\n        \"\"\"Adds columns to existing list by taking into account\n        the text that lies outside the current column x-coordinates.\n\n        Parameters\n        ----------\n        cols : list\n            List of column x-coordinate tuples.\n        text : list\n            List of PDFMiner text objects.\n        ytol : int\n\n        Returns\n        -------\n        cols : list\n            Updated list of column x-coordinate tuples.\n\n        \"\"\"\n        if text:\n            text = Stream._group_rows(text, row_tol=row_tol)\n            elements = [len(r) for r in text]\n            new_cols = [\n                (t.x0, t.x1) for r in text if len(r) == max(elements) for t in r\n            ]\n            cols.extend(Stream._merge_columns(sorted(new_cols)))\n        return cols\n\n    @staticmethod\n    def _join_columns(cols, text_x_min, text_x_max):\n        \"\"\"Makes column coordinates continuous.\n\n        Parameters\n        ----------\n        cols : list\n            List of column x-coordinate tuples.\n        text_x_min : int\n        text_y_max : int\n\n        Returns\n        -------\n        cols : list\n            Updated list of column x-coordinate tuples.\n\n        \"\"\"\n        cols = sorted(cols)\n        cols = [(cols[i][0] + cols[i - 1][1]) / 2 for i in range(1, len(cols))]\n        cols.insert(0, text_x_min)\n        cols.append(text_x_max)\n        cols = [(cols[i], cols[i + 1]) for i in range(0, len(cols) - 1)]\n        return cols\n\n    def _validate_columns(self):\n        if self.table_areas is not None and self.columns is not None:\n            if len(self.table_areas) != len(self.columns):\n                raise ValueError(\"Length of table_areas and columns\" \" should be equal\")\n\n    def _nurminen_table_detection(self, textlines):\n        \"\"\"A general implementation of the table detection algorithm\n        described by Anssi Nurminen's master's thesis.\n        Link: https://dspace.cc.tut.fi/dpub/bitstream/handle/123456789/21520/Nurminen.pdf?sequence=3\n\n        Assumes that tables are situated relatively far apart\n        vertically.\n        \"\"\"\n        # TODO: add support for arabic text #141\n        # sort textlines in reading order\n        textlines.sort(key=lambda x: (-x.y0, x.x0))\n        textedges = TextEdges(edge_tol=self.edge_tol)\n        # generate left, middle and right textedges\n        textedges.generate(textlines)\n        # select relevant edges\n        relevant_textedges = textedges.get_relevant()\n        self.textedges.extend(relevant_textedges)\n        # guess table areas using textlines and relevant edges\n        table_bbox = textedges.get_table_areas(textlines, relevant_textedges)\n        # treat whole page as table area if no table areas found\n        if not len(table_bbox):\n            table_bbox = {(0, 0, self.pdf_width, self.pdf_height): None}\n\n        return table_bbox\n\n    def _generate_table_bbox(self):\n        self.textedges = []\n        if self.table_areas is None:\n            hor_text = self.horizontal_text\n            if self.table_regions is not None:\n                # filter horizontal text\n                hor_text = []\n                for region in self.table_regions:\n                    x1, y1, x2, y2 = region.split(\",\")\n                    x1 = float(x1)\n                    y1 = float(y1)\n                    x2 = float(x2)\n                    y2 = float(y2)\n                    region_text = text_in_bbox((x1, y2, x2, y1), self.horizontal_text)\n                    hor_text.extend(region_text)\n            # find tables based on nurminen's detection algorithm\n            table_bbox = self._nurminen_table_detection(hor_text)\n        else:\n            table_bbox = {}\n            for area in self.table_areas:\n                x1, y1, x2, y2 = area.split(\",\")\n                x1 = float(x1)\n                y1 = float(y1)\n                x2 = float(x2)\n                y2 = float(y2)\n                table_bbox[(x1, y2, x2, y1)] = None\n        self.table_bbox = table_bbox\n\n    def _generate_columns_and_rows(self, table_idx, tk):\n        # select elements which lie within table_bbox\n        t_bbox = {}\n        t_bbox[\"horizontal\"] = text_in_bbox(tk, self.horizontal_text)\n        t_bbox[\"vertical\"] = text_in_bbox(tk, self.vertical_text)\n\n        t_bbox[\"horizontal\"].sort(key=lambda x: (-x.y0, x.x0))\n        t_bbox[\"vertical\"].sort(key=lambda x: (x.x0, -x.y0))\n\n        self.t_bbox = t_bbox\n\n        text_x_min, text_y_min, text_x_max, text_y_max = self._text_bbox(self.t_bbox)\n        rows_grouped = self._group_rows(self.t_bbox[\"horizontal\"], row_tol=self.row_tol)\n        rows = self._join_rows(rows_grouped, text_y_max, text_y_min)\n        elements = [len(r) for r in rows_grouped]\n\n        if self.columns is not None and self.columns[table_idx] != \"\":\n            # user has to input boundary columns too\n            # take (0, pdf_width) by default\n            # similar to else condition\n            # len can't be 1\n            cols = self.columns[table_idx].split(\",\")\n            cols = [float(c) for c in cols]\n            cols.insert(0, text_x_min)\n            cols.append(text_x_max)\n            cols = [(cols[i], cols[i + 1]) for i in range(0, len(cols) - 1)]\n        else:\n            # calculate mode of the list of number of elements in\n            # each row to guess the number of columns\n            if not len(elements):\n                cols = [(text_x_min, text_x_max)]\n            else:\n                ncols = max(set(elements), key=elements.count)\n                if ncols == 1:\n                    # if mode is 1, the page usually contains not tables\n                    # but there can be cases where the list can be skewed,\n                    # try to remove all 1s from list in this case and\n                    # see if the list contains elements, if yes, then use\n                    # the mode after removing 1s\n                    elements = list(filter(lambda x: x != 1, elements))\n                    if len(elements):\n                        ncols = max(set(elements), key=elements.count)\n                    else:\n                        warnings.warn(f\"No tables found in table area {table_idx + 1}\")\n                cols = [\n                    (t.x0, t.x1) for r in rows_grouped if len(r) == ncols for t in r\n                ]\n                cols = self._merge_columns(sorted(cols), column_tol=self.column_tol)\n                inner_text = []\n                for i in range(1, len(cols)):\n                    left = cols[i - 1][1]\n                    right = cols[i][0]\n                    inner_text.extend(\n                        [\n                            t\n                            for direction in self.t_bbox\n                            for t in self.t_bbox[direction]\n                            if t.x0 &gt; left and t.x1 &lt; right\n                        ]\n                    )\n                outer_text = [\n                    t\n                    for direction in self.t_bbox\n                    for t in self.t_bbox[direction]\n                    if t.x0 &gt; cols[-1][1] or t.x1 &lt; cols[0][0]\n                ]\n                inner_text.extend(outer_text)\n                cols = self._add_columns(cols, inner_text, self.row_tol)\n                cols = self._join_columns(cols, text_x_min, text_x_max)\n\n        return cols, rows\n\n    def _generate_table(self, table_idx, cols, rows, **kwargs):\n        table = Table(cols, rows)\n        table = table.set_all_edges()\n\n        pos_errors = []\n        # TODO: have a single list in place of two directional ones?\n        # sorted on x-coordinate based on reading order i.e. LTR or RTL\n        for direction in [\"vertical\", \"horizontal\"]:\n            for t in self.t_bbox[direction]:\n                indices, error = get_table_index(\n                    table,\n                    t,\n                    direction,\n                    split_text=self.split_text,\n                    flag_size=self.flag_size,\n                    strip_text=self.strip_text,\n                )\n                if indices[:2] != (-1, -1):\n                    pos_errors.append(error)\n                    for r_idx, c_idx, text in indices:\n                        table.cells[r_idx][c_idx].text = text\n        accuracy = compute_accuracy([[100, pos_errors]])\n\n        data = table.data\n        table.df = pd.DataFrame(data)\n        table.shape = table.df.shape\n\n        whitespace = compute_whitespace(data)\n        table.flavor = \"stream\"\n        table.accuracy = accuracy\n        table.whitespace = whitespace\n        table.order = table_idx + 1\n        table.page = int(os.path.basename(self.rootname).replace(\"page-\", \"\"))\n\n        # for plotting\n        _text = []\n        _text.extend([(t.x0, t.y0, t.x1, t.y1) for t in self.horizontal_text])\n        _text.extend([(t.x0, t.y0, t.x1, t.y1) for t in self.vertical_text])\n        table._text = _text\n        table._image = None\n        table._segments = None\n        table._textedges = self.textedges\n\n        return table\n\n    def extract_tables(self, filename, suppress_stdout=False, layout_kwargs={}):\n        self._generate_layout(filename, layout_kwargs)\n        base_filename = os.path.basename(self.rootname)\n\n        if not suppress_stdout:\n            logger.info(f\"Processing {base_filename}\")\n\n        if not self.horizontal_text:\n            if self.images:\n                warnings.warn(\n                    f\"{base_filename} is image-based, camelot only works on\"\n                    \" text-based pages.\"\n                )\n            else:\n                warnings.warn(f\"No tables found on {base_filename}\")\n            return []\n\n        self._generate_table_bbox()\n\n        _tables = []\n        # sort tables based on y-coord\n        for table_idx, tk in enumerate(\n            sorted(self.table_bbox.keys(), key=lambda x: x[1], reverse=True)\n        ):\n            cols, rows = self._generate_columns_and_rows(table_idx, tk)\n            table = self._generate_table(table_idx, cols, rows)\n            table._bbox = tk\n            _tables.append(table)\n\n        return _tables\n</code></pre>"},{"location":"api/#camelot.parsers.Lattice","title":"camelot.parsers.Lattice","text":"<p>             Bases: <code>BaseParser</code></p> <p>Lattice method of parsing looks for lines between text to parse the table.</p> <p>Parameters:</p> Name Type Description Default <code>table_regions</code> <code>list, optional (default: None)</code> <p>List of page regions that may contain tables of the form x1,y1,x2,y2 where (x1, y1) -&gt; left-top and (x2, y2) -&gt; right-bottom in PDF coordinate space.</p> <code>None</code> <code>table_areas</code> <code>list, optional (default: None)</code> <p>List of table area strings of the form x1,y1,x2,y2 where (x1, y1) -&gt; left-top and (x2, y2) -&gt; right-bottom in PDF coordinate space.</p> <code>None</code> <code>process_background</code> <code>bool, optional (default: False)</code> <p>Process background lines.</p> <code>False</code> <code>line_scale</code> <code>int, optional (default: 15)</code> <p>Line size scaling factor. The larger the value the smaller the detected lines. Making it very large will lead to text being detected as lines.</p> <code>15</code> <code>copy_text</code> <code>list, optional (default: None)</code> <p>{'h', 'v'} Direction in which text in a spanning cell will be copied over.</p> <code>None</code> <code>shift_text</code> <code>list, optional (default: ['l', 't'])</code> <p>{'l', 'r', 't', 'b'} Direction in which text in a spanning cell will flow.</p> <code>['l', 't']</code> <code>split_text</code> <code>bool, optional (default: False)</code> <p>Split text that spans across multiple cells.</p> <code>False</code> <code>flag_size</code> <code>bool, optional (default: False)</code> <p>Flag text based on font size. Useful to detect super/subscripts. Adds  around flagged text.</p> <code>False</code> <code>strip_text</code> <code>str, optional (default: '')</code> <p>Characters that should be stripped from a string before assigning it to a cell.</p> <code>''</code> <code>line_tol</code> <code>int, optional (default: 2)</code> <p>Tolerance parameter used to merge close vertical and horizontal lines.</p> <code>2</code> <code>joint_tol</code> <code>int, optional (default: 2)</code> <p>Tolerance parameter used to decide whether the detected lines and points lie close to each other.</p> <code>2</code> <code>threshold_blocksize</code> <code>int, optional (default: 15)</code> <p>Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.</p> <p>For more information, refer <code>OpenCV's adaptiveThreshold &lt;https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#adaptivethreshold&gt;</code>_.</p> <code>15</code> <code>threshold_constant</code> <code>int, optional (default: -2)</code> <p>Constant subtracted from the mean or weighted mean. Normally, it is positive but may be zero or negative as well.</p> <p>For more information, refer <code>OpenCV's adaptiveThreshold &lt;https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#adaptivethreshold&gt;</code>_.</p> <code>-2</code> <code>iterations</code> <code>int, optional (default: 0)</code> <p>Number of times for erosion/dilation is applied.</p> <p>For more information, refer <code>OpenCV's dilate &lt;https://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html#dilate&gt;</code>_.</p> <code>0</code> <code>resolution</code> <code>int, optional (default: 300)</code> <p>Resolution used for PDF to PNG conversion.</p> <code>300</code> Source code in <code>camelot/parsers/lattice.py</code> <pre><code>class Lattice(BaseParser):\n    \"\"\"Lattice method of parsing looks for lines between text\n    to parse the table.\n\n    Parameters\n    ----------\n    table_regions : list, optional (default: None)\n        List of page regions that may contain tables of the form x1,y1,x2,y2\n        where (x1, y1) -&gt; left-top and (x2, y2) -&gt; right-bottom\n        in PDF coordinate space.\n    table_areas : list, optional (default: None)\n        List of table area strings of the form x1,y1,x2,y2\n        where (x1, y1) -&gt; left-top and (x2, y2) -&gt; right-bottom\n        in PDF coordinate space.\n    process_background : bool, optional (default: False)\n        Process background lines.\n    line_scale : int, optional (default: 15)\n        Line size scaling factor. The larger the value the smaller\n        the detected lines. Making it very large will lead to text\n        being detected as lines.\n    copy_text : list, optional (default: None)\n        {'h', 'v'}\n        Direction in which text in a spanning cell will be copied\n        over.\n    shift_text : list, optional (default: ['l', 't'])\n        {'l', 'r', 't', 'b'}\n        Direction in which text in a spanning cell will flow.\n    split_text : bool, optional (default: False)\n        Split text that spans across multiple cells.\n    flag_size : bool, optional (default: False)\n        Flag text based on font size. Useful to detect\n        super/subscripts. Adds &lt;s&gt;&lt;/s&gt; around flagged text.\n    strip_text : str, optional (default: '')\n        Characters that should be stripped from a string before\n        assigning it to a cell.\n    line_tol : int, optional (default: 2)\n        Tolerance parameter used to merge close vertical and horizontal\n        lines.\n    joint_tol : int, optional (default: 2)\n        Tolerance parameter used to decide whether the detected lines\n        and points lie close to each other.\n    threshold_blocksize : int, optional (default: 15)\n        Size of a pixel neighborhood that is used to calculate a\n        threshold value for the pixel: 3, 5, 7, and so on.\n\n        For more information, refer `OpenCV's adaptiveThreshold &lt;https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#adaptivethreshold&gt;`_.\n    threshold_constant : int, optional (default: -2)\n        Constant subtracted from the mean or weighted mean.\n        Normally, it is positive but may be zero or negative as well.\n\n        For more information, refer `OpenCV's adaptiveThreshold &lt;https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#adaptivethreshold&gt;`_.\n    iterations : int, optional (default: 0)\n        Number of times for erosion/dilation is applied.\n\n        For more information, refer `OpenCV's dilate &lt;https://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html#dilate&gt;`_.\n    resolution : int, optional (default: 300)\n        Resolution used for PDF to PNG conversion.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        table_regions=None,\n        table_areas=None,\n        process_background=False,\n        line_scale=15,\n        copy_text=None,\n        shift_text=[\"l\", \"t\"],\n        split_text=False,\n        flag_size=False,\n        strip_text=\"\",\n        line_tol=2,\n        joint_tol=2,\n        threshold_blocksize=15,\n        threshold_constant=-2,\n        iterations=0,\n        resolution=300,\n        backend=\"ghostscript\",\n        **kwargs,\n    ):\n        self.table_regions = table_regions\n        self.table_areas = table_areas\n        self.process_background = process_background\n        self.line_scale = line_scale\n        self.copy_text = copy_text\n        self.shift_text = shift_text\n        self.split_text = split_text\n        self.flag_size = flag_size\n        self.strip_text = strip_text\n        self.line_tol = line_tol\n        self.joint_tol = joint_tol\n        self.threshold_blocksize = threshold_blocksize\n        self.threshold_constant = threshold_constant\n        self.iterations = iterations\n        self.resolution = resolution\n        self.backend = Lattice._get_backend(backend)\n\n    @staticmethod\n    def _get_backend(backend):\n        def implements_convert():\n            methods = [\n                method for method in dir(backend) if method.startswith(\"__\") is False\n            ]\n            return \"convert\" in methods\n\n        if isinstance(backend, str):\n            if backend not in BACKENDS.keys():\n                raise NotImplementedError(\n                    f\"Unknown backend '{backend}' specified. Please use either 'poppler' or 'ghostscript'.\"\n                )\n\n            if backend == \"ghostscript\":\n                warnings.warn(\n                    \"'ghostscript' will be replaced by 'poppler' as the default image conversion\"\n                    \" backend in v0.12.0. You can try out 'poppler' with backend='poppler'.\",\n                    DeprecationWarning,\n                )\n\n            return BACKENDS[backend]()\n        else:\n            if not implements_convert():\n                raise NotImplementedError(\n                    f\"'{backend}' must implement a 'convert' method\"\n                )\n\n            return backend\n\n    @staticmethod\n    def _reduce_index(t, idx, shift_text):\n        \"\"\"Reduces index of a text object if it lies within a spanning\n        cell.\n\n        Parameters\n        ----------\n        table : camelot.core.Table\n        idx : list\n            List of tuples of the form (r_idx, c_idx, text).\n        shift_text : list\n            {'l', 'r', 't', 'b'}\n            Select one or more strings from above and pass them as a\n            list to specify where the text in a spanning cell should\n            flow.\n\n        Returns\n        -------\n        indices : list\n            List of tuples of the form (r_idx, c_idx, text) where\n            r_idx and c_idx are new row and column indices for text.\n\n        \"\"\"\n        indices = []\n        for r_idx, c_idx, text in idx:\n            for d in shift_text:\n                if d == \"l\":\n                    if t.cells[r_idx][c_idx].hspan:\n                        while not t.cells[r_idx][c_idx].left:\n                            c_idx -= 1\n                if d == \"r\":\n                    if t.cells[r_idx][c_idx].hspan:\n                        while not t.cells[r_idx][c_idx].right:\n                            c_idx += 1\n                if d == \"t\":\n                    if t.cells[r_idx][c_idx].vspan:\n                        while not t.cells[r_idx][c_idx].top:\n                            r_idx -= 1\n                if d == \"b\":\n                    if t.cells[r_idx][c_idx].vspan:\n                        while not t.cells[r_idx][c_idx].bottom:\n                            r_idx += 1\n            indices.append((r_idx, c_idx, text))\n        return indices\n\n    @staticmethod\n    def _copy_spanning_text(t, copy_text=None):\n        \"\"\"Copies over text in empty spanning cells.\n\n        Parameters\n        ----------\n        t : camelot.core.Table\n        copy_text : list, optional (default: None)\n            {'h', 'v'}\n            Select one or more strings from above and pass them as a list\n            to specify the direction in which text should be copied over\n            when a cell spans multiple rows or columns.\n\n        Returns\n        -------\n        t : camelot.core.Table\n\n        \"\"\"\n        for f in copy_text:\n            if f == \"h\":\n                for i in range(len(t.cells)):\n                    for j in range(len(t.cells[i])):\n                        if t.cells[i][j].text.strip() == \"\":\n                            if t.cells[i][j].hspan and not t.cells[i][j].left:\n                                t.cells[i][j].text = t.cells[i][j - 1].text\n            elif f == \"v\":\n                for i in range(len(t.cells)):\n                    for j in range(len(t.cells[i])):\n                        if t.cells[i][j].text.strip() == \"\":\n                            if t.cells[i][j].vspan and not t.cells[i][j].top:\n                                t.cells[i][j].text = t.cells[i - 1][j].text\n        return t\n\n    def _generate_table_bbox(self):\n        def scale_areas(areas):\n            scaled_areas = []\n            for area in areas:\n                x1, y1, x2, y2 = area.split(\",\")\n                x1 = float(x1)\n                y1 = float(y1)\n                x2 = float(x2)\n                y2 = float(y2)\n                x1, y1, x2, y2 = scale_pdf((x1, y1, x2, y2), image_scalers)\n                scaled_areas.append((x1, y1, abs(x2 - x1), abs(y2 - y1)))\n            return scaled_areas\n\n        self.image, self.threshold = adaptive_threshold(\n            self.imagename,\n            process_background=self.process_background,\n            blocksize=self.threshold_blocksize,\n            c=self.threshold_constant,\n        )\n\n        image_width = self.image.shape[1]\n        image_height = self.image.shape[0]\n        image_width_scaler = image_width / float(self.pdf_width)\n        image_height_scaler = image_height / float(self.pdf_height)\n        pdf_width_scaler = self.pdf_width / float(image_width)\n        pdf_height_scaler = self.pdf_height / float(image_height)\n        image_scalers = (image_width_scaler, image_height_scaler, self.pdf_height)\n        pdf_scalers = (pdf_width_scaler, pdf_height_scaler, image_height)\n\n        if self.table_areas is None:\n            regions = None\n            if self.table_regions is not None:\n                regions = scale_areas(self.table_regions)\n\n            vertical_mask, vertical_segments = find_lines(\n                self.threshold,\n                regions=regions,\n                direction=\"vertical\",\n                line_scale=self.line_scale,\n                iterations=self.iterations,\n            )\n            horizontal_mask, horizontal_segments = find_lines(\n                self.threshold,\n                regions=regions,\n                direction=\"horizontal\",\n                line_scale=self.line_scale,\n                iterations=self.iterations,\n            )\n\n            contours = find_contours(vertical_mask, horizontal_mask)\n            table_bbox = find_joints(contours, vertical_mask, horizontal_mask)\n        else:\n            vertical_mask, vertical_segments = find_lines(\n                self.threshold,\n                direction=\"vertical\",\n                line_scale=self.line_scale,\n                iterations=self.iterations,\n            )\n            horizontal_mask, horizontal_segments = find_lines(\n                self.threshold,\n                direction=\"horizontal\",\n                line_scale=self.line_scale,\n                iterations=self.iterations,\n            )\n\n            areas = scale_areas(self.table_areas)\n            table_bbox = find_joints(areas, vertical_mask, horizontal_mask)\n\n        self.table_bbox_unscaled = copy.deepcopy(table_bbox)\n\n        self.table_bbox, self.vertical_segments, self.horizontal_segments = scale_image(\n            table_bbox, vertical_segments, horizontal_segments, pdf_scalers\n        )\n\n    def _generate_columns_and_rows(self, table_idx, tk):\n        # select elements which lie within table_bbox\n        t_bbox = {}\n        v_s, h_s = segments_in_bbox(\n            tk, self.vertical_segments, self.horizontal_segments\n        )\n        t_bbox[\"horizontal\"] = text_in_bbox(tk, self.horizontal_text)\n        t_bbox[\"vertical\"] = text_in_bbox(tk, self.vertical_text)\n\n        t_bbox[\"horizontal\"].sort(key=lambda x: (-x.y0, x.x0))\n        t_bbox[\"vertical\"].sort(key=lambda x: (x.x0, -x.y0))\n\n        self.t_bbox = t_bbox\n\n        cols, rows = zip(*self.table_bbox[tk])\n        cols, rows = list(cols), list(rows)\n        cols.extend([tk[0], tk[2]])\n        rows.extend([tk[1], tk[3]])\n        # sort horizontal and vertical segments\n        cols = merge_close_lines(sorted(cols), line_tol=self.line_tol)\n        rows = merge_close_lines(sorted(rows, reverse=True), line_tol=self.line_tol)\n        # make grid using x and y coord of shortlisted rows and cols\n        cols = [(cols[i], cols[i + 1]) for i in range(0, len(cols) - 1)]\n        rows = [(rows[i], rows[i + 1]) for i in range(0, len(rows) - 1)]\n\n        return cols, rows, v_s, h_s\n\n    def _generate_table(self, table_idx, cols, rows, **kwargs):\n        v_s = kwargs.get(\"v_s\")\n        h_s = kwargs.get(\"h_s\")\n        if v_s is None or h_s is None:\n            raise ValueError(f\"No segments found on {self.rootname}\")\n\n        table = Table(cols, rows)\n        # set table edges to True using ver+hor lines\n        table = table.set_edges(v_s, h_s, joint_tol=self.joint_tol)\n        # set table border edges to True\n        table = table.set_border()\n        # set spanning cells to True\n        table = table.set_span()\n\n        pos_errors = []\n        # TODO: have a single list in place of two directional ones?\n        # sorted on x-coordinate based on reading order i.e. LTR or RTL\n        for direction in [\"vertical\", \"horizontal\"]:\n            for t in self.t_bbox[direction]:\n                indices, error = get_table_index(\n                    table,\n                    t,\n                    direction,\n                    split_text=self.split_text,\n                    flag_size=self.flag_size,\n                    strip_text=self.strip_text,\n                )\n                if indices[0][:2] != (-1, -1):\n                    pos_errors.append(error)\n                    indices = Lattice._reduce_index(\n                        table, indices, shift_text=self.shift_text\n                    )\n                    for r_idx, c_idx, text in indices:\n                        table.cells[r_idx][c_idx].text = text\n        accuracy = compute_accuracy([[100, pos_errors]])\n\n        if self.copy_text is not None:\n            table = Lattice._copy_spanning_text(table, copy_text=self.copy_text)\n\n        data = table.data\n        table.df = pd.DataFrame(data)\n        table.shape = table.df.shape\n\n        whitespace = compute_whitespace(data)\n        table.flavor = \"lattice\"\n        table.accuracy = accuracy\n        table.whitespace = whitespace\n        table.order = table_idx + 1\n        table.page = int(os.path.basename(self.rootname).replace(\"page-\", \"\"))\n\n        # for plotting\n        _text = []\n        _text.extend([(t.x0, t.y0, t.x1, t.y1) for t in self.horizontal_text])\n        _text.extend([(t.x0, t.y0, t.x1, t.y1) for t in self.vertical_text])\n        table._text = _text\n        table._image = (self.image, self.table_bbox_unscaled)\n        table._segments = (self.vertical_segments, self.horizontal_segments)\n        table._textedges = None\n\n        return table\n\n    def extract_tables(self, filename, suppress_stdout=False, layout_kwargs={}):\n        self._generate_layout(filename, layout_kwargs)\n        if not suppress_stdout:\n            logger.info(f\"Processing {os.path.basename(self.rootname)}\")\n\n        if not self.horizontal_text:\n            if self.images:\n                warnings.warn(\n                    \"{} is image-based, camelot only works on\"\n                    \" text-based pages.\".format(os.path.basename(self.rootname))\n                )\n            else:\n                warnings.warn(f\"No tables found on {os.path.basename(self.rootname)}\")\n            return []\n\n        self.backend.convert(self.filename, self.imagename)\n\n        self._generate_table_bbox()\n\n        _tables = []\n        # sort tables based on y-coord\n        for table_idx, tk in enumerate(\n            sorted(self.table_bbox.keys(), key=lambda x: x[1], reverse=True)\n        ):\n            cols, rows, v_s, h_s = self._generate_columns_and_rows(table_idx, tk)\n            table = self._generate_table(table_idx, cols, rows, v_s=v_s, h_s=h_s)\n            table._bbox = tk\n            _tables.append(table)\n\n        return _tables\n</code></pre>"},{"location":"api/#low-level-classes","title":"Low-Level Classes","text":"<p>options:       show_root_heading: true</p> <p>options:       show_root_heading: true</p> <p>options:       show_root_heading: true</p>"},{"location":"api/#camelot.core.TableList","title":"camelot.core.TableList","text":"<p>Defines a list of camelot.core.Table objects. Each table can be accessed using its index.</p> <p>Attributes:</p> Name Type Description <code>n</code> <code>int</code> <p>Number of tables in the list.</p> Source code in <code>camelot/core.py</code> <pre><code>class TableList:\n    \"\"\"Defines a list of camelot.core.Table objects. Each table can\n    be accessed using its index.\n\n    Attributes\n    ----------\n    n : int\n        Number of tables in the list.\n\n    \"\"\"\n\n    def __init__(self, tables):\n        self._tables = tables\n\n    def __repr__(self):\n        return f\"&lt;{self.__class__.__name__} n={self.n}&gt;\"\n\n    def __len__(self):\n        return len(self._tables)\n\n    def __getitem__(self, idx):\n        return self._tables[idx]\n\n    @staticmethod\n    def _format_func(table, f):\n        return getattr(table, f\"to_{f}\")\n\n    @property\n    def n(self):\n        return len(self)\n\n    def _write_file(self, f=None, **kwargs):\n        dirname = kwargs.get(\"dirname\")\n        root = kwargs.get(\"root\")\n        ext = kwargs.get(\"ext\")\n        for table in self._tables:\n            filename = f\"{root}-page-{table.page}-table-{table.order}{ext}\"\n            filepath = os.path.join(dirname, filename)\n            to_format = self._format_func(table, f)\n            to_format(filepath)\n\n    def _compress_dir(self, **kwargs):\n        path = kwargs.get(\"path\")\n        dirname = kwargs.get(\"dirname\")\n        root = kwargs.get(\"root\")\n        ext = kwargs.get(\"ext\")\n        zipname = os.path.join(os.path.dirname(path), root) + \".zip\"\n        with zipfile.ZipFile(zipname, \"w\", allowZip64=True) as z:\n            for table in self._tables:\n                filename = f\"{root}-page-{table.page}-table-{table.order}{ext}\"\n                filepath = os.path.join(dirname, filename)\n                z.write(filepath, os.path.basename(filepath))\n\n    def export(self, path, f=\"csv\", compress=False):\n        \"\"\"Exports the list of tables to specified file format.\n\n        Parameters\n        ----------\n        path : str\n            Output filepath.\n        f : str\n            File format. Can be csv, excel, html, json, markdown or sqlite.\n        compress : bool\n            Whether or not to add files to a ZIP archive.\n\n        \"\"\"\n        dirname = os.path.dirname(path)\n        basename = os.path.basename(path)\n        root, ext = os.path.splitext(basename)\n        if compress:\n            dirname = tempfile.mkdtemp()\n\n        kwargs = {\"path\": path, \"dirname\": dirname, \"root\": root, \"ext\": ext}\n\n        if f in [\"csv\", \"html\", \"json\", \"markdown\"]:\n            self._write_file(f=f, **kwargs)\n            if compress:\n                self._compress_dir(**kwargs)\n        elif f == \"excel\":\n            filepath = os.path.join(dirname, basename)\n            writer = pd.ExcelWriter(filepath)\n            for table in self._tables:\n                sheet_name = f\"page-{table.page}-table-{table.order}\"\n                table.df.to_excel(writer, sheet_name=sheet_name)\n            writer.close()\n            if compress:\n                zipname = os.path.join(os.path.dirname(path), root) + \".zip\"\n                with zipfile.ZipFile(zipname, \"w\", allowZip64=True) as z:\n                    z.write(filepath, os.path.basename(filepath))\n        elif f == \"sqlite\":\n            filepath = os.path.join(dirname, basename)\n            for table in self._tables:\n                table.to_sqlite(filepath)\n            if compress:\n                zipname = os.path.join(os.path.dirname(path), root) + \".zip\"\n                with zipfile.ZipFile(zipname, \"w\", allowZip64=True) as z:\n                    z.write(filepath, os.path.basename(filepath))\n</code></pre>"},{"location":"api/#camelot.core.TableList.export","title":"camelot.core.TableList.export","text":"<pre><code>export(path, f='csv', compress=False)\n</code></pre> <p>Exports the list of tables to specified file format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Output filepath.</p> required <code>f</code> <code>str</code> <p>File format. Can be csv, excel, html, json, markdown or sqlite.</p> <code>'csv'</code> <code>compress</code> <code>bool</code> <p>Whether or not to add files to a ZIP archive.</p> <code>False</code> Source code in <code>camelot/core.py</code> <pre><code>def export(self, path, f=\"csv\", compress=False):\n    \"\"\"Exports the list of tables to specified file format.\n\n    Parameters\n    ----------\n    path : str\n        Output filepath.\n    f : str\n        File format. Can be csv, excel, html, json, markdown or sqlite.\n    compress : bool\n        Whether or not to add files to a ZIP archive.\n\n    \"\"\"\n    dirname = os.path.dirname(path)\n    basename = os.path.basename(path)\n    root, ext = os.path.splitext(basename)\n    if compress:\n        dirname = tempfile.mkdtemp()\n\n    kwargs = {\"path\": path, \"dirname\": dirname, \"root\": root, \"ext\": ext}\n\n    if f in [\"csv\", \"html\", \"json\", \"markdown\"]:\n        self._write_file(f=f, **kwargs)\n        if compress:\n            self._compress_dir(**kwargs)\n    elif f == \"excel\":\n        filepath = os.path.join(dirname, basename)\n        writer = pd.ExcelWriter(filepath)\n        for table in self._tables:\n            sheet_name = f\"page-{table.page}-table-{table.order}\"\n            table.df.to_excel(writer, sheet_name=sheet_name)\n        writer.close()\n        if compress:\n            zipname = os.path.join(os.path.dirname(path), root) + \".zip\"\n            with zipfile.ZipFile(zipname, \"w\", allowZip64=True) as z:\n                z.write(filepath, os.path.basename(filepath))\n    elif f == \"sqlite\":\n        filepath = os.path.join(dirname, basename)\n        for table in self._tables:\n            table.to_sqlite(filepath)\n        if compress:\n            zipname = os.path.join(os.path.dirname(path), root) + \".zip\"\n            with zipfile.ZipFile(zipname, \"w\", allowZip64=True) as z:\n                z.write(filepath, os.path.basename(filepath))\n</code></pre>"},{"location":"api/#camelot.core.Table","title":"camelot.core.Table","text":"<p>Defines a table with coordinates relative to a left-bottom origin. (PDF coordinate space)</p> <p>Parameters:</p> Name Type Description Default <code>cols</code> <code>list</code> <p>List of tuples representing column x-coordinates in increasing order.</p> required <code>rows</code> <code>list</code> <p>List of tuples representing row y-coordinates in decreasing order.</p> required <p>Attributes:</p> Name Type Description <code>df</code> <code>:class:`pandas.DataFrame`</code> <code>shape</code> <code>tuple</code> <p>Shape of the table.</p> <code>accuracy</code> <code>float</code> <p>Accuracy with which text was assigned to the cell.</p> <code>whitespace</code> <code>float</code> <p>Percentage of whitespace in the table.</p> <code>order</code> <code>int</code> <p>Table number on PDF page.</p> <code>page</code> <code>int</code> <p>PDF page number.</p> Source code in <code>camelot/core.py</code> <pre><code>class Table:\n    \"\"\"Defines a table with coordinates relative to a left-bottom\n    origin. (PDF coordinate space)\n\n    Parameters\n    ----------\n    cols : list\n        List of tuples representing column x-coordinates in increasing\n        order.\n    rows : list\n        List of tuples representing row y-coordinates in decreasing\n        order.\n\n    Attributes\n    ----------\n    df : :class:`pandas.DataFrame`\n    shape : tuple\n        Shape of the table.\n    accuracy : float\n        Accuracy with which text was assigned to the cell.\n    whitespace : float\n        Percentage of whitespace in the table.\n    order : int\n        Table number on PDF page.\n    page : int\n        PDF page number.\n\n    \"\"\"\n\n    def __init__(self, cols, rows):\n        self.cols = cols\n        self.rows = rows\n        self.cells = [[Cell(c[0], r[1], c[1], r[0]) for c in cols] for r in rows]\n        self.df = pd.DataFrame()\n        self.shape = (0, 0)\n        self.accuracy = 0\n        self.whitespace = 0\n        self.order = None\n        self.page = None\n\n    def __repr__(self):\n        return f\"&lt;{self.__class__.__name__} shape={self.shape}&gt;\"\n\n    def __lt__(self, other):\n        if self.page == other.page:\n            if self.order &lt; other.order:\n                return True\n        if self.page &lt; other.page:\n            return True\n\n    @property\n    def data(self):\n        \"\"\"Returns two-dimensional list of strings in table.\"\"\"\n        d = []\n        for row in self.cells:\n            d.append([cell.text.strip() for cell in row])\n        return d\n\n    @property\n    def parsing_report(self):\n        \"\"\"Returns a parsing report with %accuracy, %whitespace,\n        table number on page and page number.\n        \"\"\"\n        # pretty?\n        report = {\n            \"accuracy\": round(self.accuracy, 2),\n            \"whitespace\": round(self.whitespace, 2),\n            \"order\": self.order,\n            \"page\": self.page,\n        }\n        return report\n\n    def set_all_edges(self):\n        \"\"\"Sets all table edges to True.\"\"\"\n        for row in self.cells:\n            for cell in row:\n                cell.left = cell.right = cell.top = cell.bottom = True\n        return self\n\n    def set_edges(self, vertical, horizontal, joint_tol=2):\n        \"\"\"Sets a cell's edges to True depending on whether the cell's\n        coordinates overlap with the line's coordinates within a\n        tolerance.\n\n        Parameters\n        ----------\n        vertical : list\n            List of detected vertical lines.\n        horizontal : list\n            List of detected horizontal lines.\n\n        \"\"\"\n        for v in vertical:\n            # find closest x coord\n            # iterate over y coords and find closest start and end points\n            i = [\n                i\n                for i, t in enumerate(self.cols)\n                if np.isclose(v[0], t[0], atol=joint_tol)\n            ]\n            j = [\n                j\n                for j, t in enumerate(self.rows)\n                if np.isclose(v[3], t[0], atol=joint_tol)\n            ]\n            k = [\n                k\n                for k, t in enumerate(self.rows)\n                if np.isclose(v[1], t[0], atol=joint_tol)\n            ]\n            if not j:\n                continue\n            J = j[0]\n            if i == [0]:  # only left edge\n                L = i[0]\n                if k:\n                    K = k[0]\n                    while J &lt; K:\n                        self.cells[J][L].left = True\n                        J += 1\n                else:\n                    K = len(self.rows)\n                    while J &lt; K:\n                        self.cells[J][L].left = True\n                        J += 1\n            elif i == []:  # only right edge\n                L = len(self.cols) - 1\n                if k:\n                    K = k[0]\n                    while J &lt; K:\n                        self.cells[J][L].right = True\n                        J += 1\n                else:\n                    K = len(self.rows)\n                    while J &lt; K:\n                        self.cells[J][L].right = True\n                        J += 1\n            else:  # both left and right edges\n                L = i[0]\n                if k:\n                    K = k[0]\n                    while J &lt; K:\n                        self.cells[J][L].left = True\n                        self.cells[J][L - 1].right = True\n                        J += 1\n                else:\n                    K = len(self.rows)\n                    while J &lt; K:\n                        self.cells[J][L].left = True\n                        self.cells[J][L - 1].right = True\n                        J += 1\n\n        for h in horizontal:\n            # find closest y coord\n            # iterate over x coords and find closest start and end points\n            i = [\n                i\n                for i, t in enumerate(self.rows)\n                if np.isclose(h[1], t[0], atol=joint_tol)\n            ]\n            j = [\n                j\n                for j, t in enumerate(self.cols)\n                if np.isclose(h[0], t[0], atol=joint_tol)\n            ]\n            k = [\n                k\n                for k, t in enumerate(self.cols)\n                if np.isclose(h[2], t[0], atol=joint_tol)\n            ]\n            if not j:\n                continue\n            J = j[0]\n            if i == [0]:  # only top edge\n                L = i[0]\n                if k:\n                    K = k[0]\n                    while J &lt; K:\n                        self.cells[L][J].top = True\n                        J += 1\n                else:\n                    K = len(self.cols)\n                    while J &lt; K:\n                        self.cells[L][J].top = True\n                        J += 1\n            elif i == []:  # only bottom edge\n                L = len(self.rows) - 1\n                if k:\n                    K = k[0]\n                    while J &lt; K:\n                        self.cells[L][J].bottom = True\n                        J += 1\n                else:\n                    K = len(self.cols)\n                    while J &lt; K:\n                        self.cells[L][J].bottom = True\n                        J += 1\n            else:  # both top and bottom edges\n                L = i[0]\n                if k:\n                    K = k[0]\n                    while J &lt; K:\n                        self.cells[L][J].top = True\n                        self.cells[L - 1][J].bottom = True\n                        J += 1\n                else:\n                    K = len(self.cols)\n                    while J &lt; K:\n                        self.cells[L][J].top = True\n                        self.cells[L - 1][J].bottom = True\n                        J += 1\n\n        return self\n\n    def set_border(self):\n        \"\"\"Sets table border edges to True.\"\"\"\n        for r in range(len(self.rows)):\n            self.cells[r][0].left = True\n            self.cells[r][len(self.cols) - 1].right = True\n        for c in range(len(self.cols)):\n            self.cells[0][c].top = True\n            self.cells[len(self.rows) - 1][c].bottom = True\n        return self\n\n    def set_span(self):\n        \"\"\"Sets a cell's hspan or vspan attribute to True depending\n        on whether the cell spans horizontally or vertically.\n        \"\"\"\n        for row in self.cells:\n            for cell in row:\n                left = cell.left\n                right = cell.right\n                top = cell.top\n                bottom = cell.bottom\n                if cell.bound == 4:\n                    continue\n                elif cell.bound == 3:\n                    if not left and (right and top and bottom):\n                        cell.hspan = True\n                    elif not right and (left and top and bottom):\n                        cell.hspan = True\n                    elif not top and (left and right and bottom):\n                        cell.vspan = True\n                    elif not bottom and (left and right and top):\n                        cell.vspan = True\n                elif cell.bound == 2:\n                    if left and right and (not top and not bottom):\n                        cell.vspan = True\n                    elif top and bottom and (not left and not right):\n                        cell.hspan = True\n                elif cell.bound in [0, 1]:\n                    cell.vspan = True\n                    cell.hspan = True\n        return self\n\n    def to_csv(self, path, **kwargs):\n        \"\"\"Writes Table to a comma-separated values (csv) file.\n\n        For kwargs, check :meth:`pandas.DataFrame.to_csv`.\n\n        Parameters\n        ----------\n        path : str\n            Output filepath.\n\n        \"\"\"\n        kw = {\"encoding\": \"utf-8\", \"index\": False, \"header\": False, \"quoting\": 1}\n        kw.update(kwargs)\n        self.df.to_csv(path, **kw)\n\n    def to_json(self, path, **kwargs):\n        \"\"\"Writes Table to a JSON file.\n\n        For kwargs, check :meth:`pandas.DataFrame.to_json`.\n\n        Parameters\n        ----------\n        path : str\n            Output filepath.\n\n        \"\"\"\n        kw = {\"orient\": \"records\"}\n        kw.update(kwargs)\n        json_string = self.df.to_json(**kw)\n        with open(path, \"w\") as f:\n            f.write(json_string)\n\n    def to_excel(self, path, **kwargs):\n        \"\"\"Writes Table to an Excel file.\n\n        For kwargs, check :meth:`pandas.DataFrame.to_excel`.\n\n        Parameters\n        ----------\n        path : str\n            Output filepath.\n\n        \"\"\"\n        kw = {\n            \"sheet_name\": f\"page-{self.page}-table-{self.order}\",\n            \"encoding\": \"utf-8\",\n        }\n        kw.update(kwargs)\n        writer = pd.ExcelWriter(path)\n        self.df.to_excel(writer, **kw)\n        writer.save()\n\n    def to_html(self, path, **kwargs):\n        \"\"\"Writes Table to an HTML file.\n\n        For kwargs, check :meth:`pandas.DataFrame.to_html`.\n\n        Parameters\n        ----------\n        path : str\n            Output filepath.\n\n        \"\"\"\n        html_string = self.df.to_html(**kwargs)\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            f.write(html_string)\n\n    def to_markdown(self, path, **kwargs):\n        \"\"\"Writes Table to a Markdown file.\n\n        For kwargs, check :meth:`pandas.DataFrame.to_markdown`.\n\n        Parameters\n        ----------\n        path : str\n            Output filepath.\n\n        \"\"\"\n        md_string = self.df.to_markdown(**kwargs)\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            f.write(md_string)\n\n    def to_sqlite(self, path, **kwargs):\n        \"\"\"Writes Table to sqlite database.\n\n        For kwargs, check :meth:`pandas.DataFrame.to_sql`.\n\n        Parameters\n        ----------\n        path : str\n            Output filepath.\n\n        \"\"\"\n        kw = {\"if_exists\": \"replace\", \"index\": False}\n        kw.update(kwargs)\n        conn = sqlite3.connect(path)\n        table_name = f\"page-{self.page}-table-{self.order}\"\n        self.df.to_sql(table_name, conn, **kw)\n        conn.commit()\n        conn.close()\n</code></pre>"},{"location":"api/#camelot.core.Table.data","title":"camelot.core.Table.data  <code>property</code>","text":"<pre><code>data\n</code></pre> <p>Returns two-dimensional list of strings in table.</p>"},{"location":"api/#camelot.core.Table.parsing_report","title":"camelot.core.Table.parsing_report  <code>property</code>","text":"<pre><code>parsing_report\n</code></pre> <p>Returns a parsing report with %accuracy, %whitespace, table number on page and page number.</p>"},{"location":"api/#camelot.core.Table.set_all_edges","title":"camelot.core.Table.set_all_edges","text":"<pre><code>set_all_edges()\n</code></pre> <p>Sets all table edges to True.</p> Source code in <code>camelot/core.py</code> <pre><code>def set_all_edges(self):\n    \"\"\"Sets all table edges to True.\"\"\"\n    for row in self.cells:\n        for cell in row:\n            cell.left = cell.right = cell.top = cell.bottom = True\n    return self\n</code></pre>"},{"location":"api/#camelot.core.Table.set_border","title":"camelot.core.Table.set_border","text":"<pre><code>set_border()\n</code></pre> <p>Sets table border edges to True.</p> Source code in <code>camelot/core.py</code> <pre><code>def set_border(self):\n    \"\"\"Sets table border edges to True.\"\"\"\n    for r in range(len(self.rows)):\n        self.cells[r][0].left = True\n        self.cells[r][len(self.cols) - 1].right = True\n    for c in range(len(self.cols)):\n        self.cells[0][c].top = True\n        self.cells[len(self.rows) - 1][c].bottom = True\n    return self\n</code></pre>"},{"location":"api/#camelot.core.Table.set_edges","title":"camelot.core.Table.set_edges","text":"<pre><code>set_edges(vertical, horizontal, joint_tol=2)\n</code></pre> <p>Sets a cell's edges to True depending on whether the cell's coordinates overlap with the line's coordinates within a tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>vertical</code> <code>list</code> <p>List of detected vertical lines.</p> required <code>horizontal</code> <code>list</code> <p>List of detected horizontal lines.</p> required Source code in <code>camelot/core.py</code> <pre><code>def set_edges(self, vertical, horizontal, joint_tol=2):\n    \"\"\"Sets a cell's edges to True depending on whether the cell's\n    coordinates overlap with the line's coordinates within a\n    tolerance.\n\n    Parameters\n    ----------\n    vertical : list\n        List of detected vertical lines.\n    horizontal : list\n        List of detected horizontal lines.\n\n    \"\"\"\n    for v in vertical:\n        # find closest x coord\n        # iterate over y coords and find closest start and end points\n        i = [\n            i\n            for i, t in enumerate(self.cols)\n            if np.isclose(v[0], t[0], atol=joint_tol)\n        ]\n        j = [\n            j\n            for j, t in enumerate(self.rows)\n            if np.isclose(v[3], t[0], atol=joint_tol)\n        ]\n        k = [\n            k\n            for k, t in enumerate(self.rows)\n            if np.isclose(v[1], t[0], atol=joint_tol)\n        ]\n        if not j:\n            continue\n        J = j[0]\n        if i == [0]:  # only left edge\n            L = i[0]\n            if k:\n                K = k[0]\n                while J &lt; K:\n                    self.cells[J][L].left = True\n                    J += 1\n            else:\n                K = len(self.rows)\n                while J &lt; K:\n                    self.cells[J][L].left = True\n                    J += 1\n        elif i == []:  # only right edge\n            L = len(self.cols) - 1\n            if k:\n                K = k[0]\n                while J &lt; K:\n                    self.cells[J][L].right = True\n                    J += 1\n            else:\n                K = len(self.rows)\n                while J &lt; K:\n                    self.cells[J][L].right = True\n                    J += 1\n        else:  # both left and right edges\n            L = i[0]\n            if k:\n                K = k[0]\n                while J &lt; K:\n                    self.cells[J][L].left = True\n                    self.cells[J][L - 1].right = True\n                    J += 1\n            else:\n                K = len(self.rows)\n                while J &lt; K:\n                    self.cells[J][L].left = True\n                    self.cells[J][L - 1].right = True\n                    J += 1\n\n    for h in horizontal:\n        # find closest y coord\n        # iterate over x coords and find closest start and end points\n        i = [\n            i\n            for i, t in enumerate(self.rows)\n            if np.isclose(h[1], t[0], atol=joint_tol)\n        ]\n        j = [\n            j\n            for j, t in enumerate(self.cols)\n            if np.isclose(h[0], t[0], atol=joint_tol)\n        ]\n        k = [\n            k\n            for k, t in enumerate(self.cols)\n            if np.isclose(h[2], t[0], atol=joint_tol)\n        ]\n        if not j:\n            continue\n        J = j[0]\n        if i == [0]:  # only top edge\n            L = i[0]\n            if k:\n                K = k[0]\n                while J &lt; K:\n                    self.cells[L][J].top = True\n                    J += 1\n            else:\n                K = len(self.cols)\n                while J &lt; K:\n                    self.cells[L][J].top = True\n                    J += 1\n        elif i == []:  # only bottom edge\n            L = len(self.rows) - 1\n            if k:\n                K = k[0]\n                while J &lt; K:\n                    self.cells[L][J].bottom = True\n                    J += 1\n            else:\n                K = len(self.cols)\n                while J &lt; K:\n                    self.cells[L][J].bottom = True\n                    J += 1\n        else:  # both top and bottom edges\n            L = i[0]\n            if k:\n                K = k[0]\n                while J &lt; K:\n                    self.cells[L][J].top = True\n                    self.cells[L - 1][J].bottom = True\n                    J += 1\n            else:\n                K = len(self.cols)\n                while J &lt; K:\n                    self.cells[L][J].top = True\n                    self.cells[L - 1][J].bottom = True\n                    J += 1\n\n    return self\n</code></pre>"},{"location":"api/#camelot.core.Table.set_span","title":"camelot.core.Table.set_span","text":"<pre><code>set_span()\n</code></pre> <p>Sets a cell's hspan or vspan attribute to True depending on whether the cell spans horizontally or vertically.</p> Source code in <code>camelot/core.py</code> <pre><code>def set_span(self):\n    \"\"\"Sets a cell's hspan or vspan attribute to True depending\n    on whether the cell spans horizontally or vertically.\n    \"\"\"\n    for row in self.cells:\n        for cell in row:\n            left = cell.left\n            right = cell.right\n            top = cell.top\n            bottom = cell.bottom\n            if cell.bound == 4:\n                continue\n            elif cell.bound == 3:\n                if not left and (right and top and bottom):\n                    cell.hspan = True\n                elif not right and (left and top and bottom):\n                    cell.hspan = True\n                elif not top and (left and right and bottom):\n                    cell.vspan = True\n                elif not bottom and (left and right and top):\n                    cell.vspan = True\n            elif cell.bound == 2:\n                if left and right and (not top and not bottom):\n                    cell.vspan = True\n                elif top and bottom and (not left and not right):\n                    cell.hspan = True\n            elif cell.bound in [0, 1]:\n                cell.vspan = True\n                cell.hspan = True\n    return self\n</code></pre>"},{"location":"api/#camelot.core.Table.to_csv","title":"camelot.core.Table.to_csv","text":"<pre><code>to_csv(path, **kwargs)\n</code></pre> <p>Writes Table to a comma-separated values (csv) file.</p> <p>For kwargs, check :meth:<code>pandas.DataFrame.to_csv</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Output filepath.</p> required Source code in <code>camelot/core.py</code> <pre><code>def to_csv(self, path, **kwargs):\n    \"\"\"Writes Table to a comma-separated values (csv) file.\n\n    For kwargs, check :meth:`pandas.DataFrame.to_csv`.\n\n    Parameters\n    ----------\n    path : str\n        Output filepath.\n\n    \"\"\"\n    kw = {\"encoding\": \"utf-8\", \"index\": False, \"header\": False, \"quoting\": 1}\n    kw.update(kwargs)\n    self.df.to_csv(path, **kw)\n</code></pre>"},{"location":"api/#camelot.core.Table.to_excel","title":"camelot.core.Table.to_excel","text":"<pre><code>to_excel(path, **kwargs)\n</code></pre> <p>Writes Table to an Excel file.</p> <p>For kwargs, check :meth:<code>pandas.DataFrame.to_excel</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Output filepath.</p> required Source code in <code>camelot/core.py</code> <pre><code>def to_excel(self, path, **kwargs):\n    \"\"\"Writes Table to an Excel file.\n\n    For kwargs, check :meth:`pandas.DataFrame.to_excel`.\n\n    Parameters\n    ----------\n    path : str\n        Output filepath.\n\n    \"\"\"\n    kw = {\n        \"sheet_name\": f\"page-{self.page}-table-{self.order}\",\n        \"encoding\": \"utf-8\",\n    }\n    kw.update(kwargs)\n    writer = pd.ExcelWriter(path)\n    self.df.to_excel(writer, **kw)\n    writer.save()\n</code></pre>"},{"location":"api/#camelot.core.Table.to_html","title":"camelot.core.Table.to_html","text":"<pre><code>to_html(path, **kwargs)\n</code></pre> <p>Writes Table to an HTML file.</p> <p>For kwargs, check :meth:<code>pandas.DataFrame.to_html</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Output filepath.</p> required Source code in <code>camelot/core.py</code> <pre><code>def to_html(self, path, **kwargs):\n    \"\"\"Writes Table to an HTML file.\n\n    For kwargs, check :meth:`pandas.DataFrame.to_html`.\n\n    Parameters\n    ----------\n    path : str\n        Output filepath.\n\n    \"\"\"\n    html_string = self.df.to_html(**kwargs)\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        f.write(html_string)\n</code></pre>"},{"location":"api/#camelot.core.Table.to_json","title":"camelot.core.Table.to_json","text":"<pre><code>to_json(path, **kwargs)\n</code></pre> <p>Writes Table to a JSON file.</p> <p>For kwargs, check :meth:<code>pandas.DataFrame.to_json</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Output filepath.</p> required Source code in <code>camelot/core.py</code> <pre><code>def to_json(self, path, **kwargs):\n    \"\"\"Writes Table to a JSON file.\n\n    For kwargs, check :meth:`pandas.DataFrame.to_json`.\n\n    Parameters\n    ----------\n    path : str\n        Output filepath.\n\n    \"\"\"\n    kw = {\"orient\": \"records\"}\n    kw.update(kwargs)\n    json_string = self.df.to_json(**kw)\n    with open(path, \"w\") as f:\n        f.write(json_string)\n</code></pre>"},{"location":"api/#camelot.core.Table.to_markdown","title":"camelot.core.Table.to_markdown","text":"<pre><code>to_markdown(path, **kwargs)\n</code></pre> <p>Writes Table to a Markdown file.</p> <p>For kwargs, check :meth:<code>pandas.DataFrame.to_markdown</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Output filepath.</p> required Source code in <code>camelot/core.py</code> <pre><code>def to_markdown(self, path, **kwargs):\n    \"\"\"Writes Table to a Markdown file.\n\n    For kwargs, check :meth:`pandas.DataFrame.to_markdown`.\n\n    Parameters\n    ----------\n    path : str\n        Output filepath.\n\n    \"\"\"\n    md_string = self.df.to_markdown(**kwargs)\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        f.write(md_string)\n</code></pre>"},{"location":"api/#camelot.core.Table.to_sqlite","title":"camelot.core.Table.to_sqlite","text":"<pre><code>to_sqlite(path, **kwargs)\n</code></pre> <p>Writes Table to sqlite database.</p> <p>For kwargs, check :meth:<code>pandas.DataFrame.to_sql</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Output filepath.</p> required Source code in <code>camelot/core.py</code> <pre><code>def to_sqlite(self, path, **kwargs):\n    \"\"\"Writes Table to sqlite database.\n\n    For kwargs, check :meth:`pandas.DataFrame.to_sql`.\n\n    Parameters\n    ----------\n    path : str\n        Output filepath.\n\n    \"\"\"\n    kw = {\"if_exists\": \"replace\", \"index\": False}\n    kw.update(kwargs)\n    conn = sqlite3.connect(path)\n    table_name = f\"page-{self.page}-table-{self.order}\"\n    self.df.to_sql(table_name, conn, **kw)\n    conn.commit()\n    conn.close()\n</code></pre>"},{"location":"api/#camelot.core.Cell","title":"camelot.core.Cell","text":"<p>Defines a cell in a table with coordinates relative to a left-bottom origin. (PDF coordinate space)</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>float</code> <p>x-coordinate of left-bottom point.</p> required <code>y1</code> <code>float</code> <p>y-coordinate of left-bottom point.</p> required <code>x2</code> <code>float</code> <p>x-coordinate of right-top point.</p> required <code>y2</code> <code>float</code> <p>y-coordinate of right-top point.</p> required <p>Attributes:</p> Name Type Description <code>lb</code> <code>tuple</code> <p>Tuple representing left-bottom coordinates.</p> <code>lt</code> <code>tuple</code> <p>Tuple representing left-top coordinates.</p> <code>rb</code> <code>tuple</code> <p>Tuple representing right-bottom coordinates.</p> <code>rt</code> <code>tuple</code> <p>Tuple representing right-top coordinates.</p> <code>left</code> <code>bool</code> <p>Whether or not cell is bounded on the left.</p> <code>right</code> <code>bool</code> <p>Whether or not cell is bounded on the right.</p> <code>top</code> <code>bool</code> <p>Whether or not cell is bounded on the top.</p> <code>bottom</code> <code>bool</code> <p>Whether or not cell is bounded on the bottom.</p> <code>hspan</code> <code>bool</code> <p>Whether or not cell spans horizontally.</p> <code>vspan</code> <code>bool</code> <p>Whether or not cell spans vertically.</p> <code>text</code> <code>string</code> <p>Text assigned to cell.</p> Source code in <code>camelot/core.py</code> <pre><code>class Cell:\n    \"\"\"Defines a cell in a table with coordinates relative to a\n    left-bottom origin. (PDF coordinate space)\n\n    Parameters\n    ----------\n    x1 : float\n        x-coordinate of left-bottom point.\n    y1 : float\n        y-coordinate of left-bottom point.\n    x2 : float\n        x-coordinate of right-top point.\n    y2 : float\n        y-coordinate of right-top point.\n\n    Attributes\n    ----------\n    lb : tuple\n        Tuple representing left-bottom coordinates.\n    lt : tuple\n        Tuple representing left-top coordinates.\n    rb : tuple\n        Tuple representing right-bottom coordinates.\n    rt : tuple\n        Tuple representing right-top coordinates.\n    left : bool\n        Whether or not cell is bounded on the left.\n    right : bool\n        Whether or not cell is bounded on the right.\n    top : bool\n        Whether or not cell is bounded on the top.\n    bottom : bool\n        Whether or not cell is bounded on the bottom.\n    hspan : bool\n        Whether or not cell spans horizontally.\n    vspan : bool\n        Whether or not cell spans vertically.\n    text : string\n        Text assigned to cell.\n\n    \"\"\"\n\n    def __init__(self, x1, y1, x2, y2):\n        self.x1 = x1\n        self.y1 = y1\n        self.x2 = x2\n        self.y2 = y2\n        self.lb = (x1, y1)\n        self.lt = (x1, y2)\n        self.rb = (x2, y1)\n        self.rt = (x2, y2)\n        self.left = False\n        self.right = False\n        self.top = False\n        self.bottom = False\n        self.hspan = False\n        self.vspan = False\n        self._text = \"\"\n\n    def __repr__(self):\n        x1 = round(self.x1)\n        y1 = round(self.y1)\n        x2 = round(self.x2)\n        y2 = round(self.y2)\n        return f\"&lt;Cell x1={x1} y1={y1} x2={x2} y2={y2}&gt;\"\n\n    @property\n    def text(self):\n        return self._text\n\n    @text.setter\n    def text(self, t):\n        self._text = \"\".join([self._text, t])\n\n    @property\n    def bound(self):\n        \"\"\"The number of sides on which the cell is bounded.\"\"\"\n        return self.top + self.bottom + self.left + self.right\n</code></pre>"},{"location":"api/#camelot.core.Cell.bound","title":"camelot.core.Cell.bound  <code>property</code>","text":"<pre><code>bound\n</code></pre> <p>The number of sides on which the cell is bounded.</p>"},{"location":"api/#plotting","title":"Plotting","text":"<p>options:       show_root_heading: true</p>"},{"location":"api/#camelot.plotting.PlotMethods","title":"camelot.plotting.PlotMethods","text":"Source code in <code>camelot/plotting.py</code> <pre><code>class PlotMethods:\n    def __call__(self, table, kind=\"text\", filename=None):\n        \"\"\"Plot elements found on PDF page based on kind\n        specified, useful for debugging and playing with different\n        parameters to get the best output.\n\n        Parameters\n        ----------\n        table: camelot.core.Table\n            A Camelot Table.\n        kind : str, optional (default: 'text')\n            {'text', 'grid', 'contour', 'joint', 'line'}\n            The element type for which a plot should be generated.\n        filepath: str, optional (default: None)\n            Absolute path for saving the generated plot.\n\n        Returns\n        -------\n        fig : matplotlib.fig.Figure\n\n        \"\"\"\n        if not _HAS_MPL:\n            raise ImportError(\"matplotlib is required for plotting.\")\n\n        if table.flavor == \"lattice\" and kind in [\"textedge\"]:\n            raise NotImplementedError(f\"Lattice flavor does not support kind='{kind}'\")\n        elif table.flavor == \"stream\" and kind in [\"joint\", \"line\"]:\n            raise NotImplementedError(f\"Stream flavor does not support kind='{kind}'\")\n\n        plot_method = getattr(self, kind)\n        fig = plot_method(table)\n\n        if filename is not None:\n            fig.savefig(filename)\n            return None\n\n        return fig\n\n    def text(self, table):\n        \"\"\"Generates a plot for all text elements present\n        on the PDF page.\n\n        Parameters\n        ----------\n        table : camelot.core.Table\n\n        Returns\n        -------\n        fig : matplotlib.fig.Figure\n\n        \"\"\"\n        fig = plt.figure()\n        ax = fig.add_subplot(111, aspect=\"equal\")\n        xs, ys = [], []\n        for t in table._text:\n            xs.extend([t[0], t[2]])\n            ys.extend([t[1], t[3]])\n            ax.add_patch(patches.Rectangle((t[0], t[1]), t[2] - t[0], t[3] - t[1]))\n        ax.set_xlim(min(xs) - 10, max(xs) + 10)\n        ax.set_ylim(min(ys) - 10, max(ys) + 10)\n        return fig\n\n    def grid(self, table):\n        \"\"\"Generates a plot for the detected table grids\n        on the PDF page.\n\n        Parameters\n        ----------\n        table : camelot.core.Table\n\n        Returns\n        -------\n        fig : matplotlib.fig.Figure\n\n        \"\"\"\n        fig = plt.figure()\n        ax = fig.add_subplot(111, aspect=\"equal\")\n        for row in table.cells:\n            for cell in row:\n                if cell.left:\n                    ax.plot([cell.lb[0], cell.lt[0]], [cell.lb[1], cell.lt[1]])\n                if cell.right:\n                    ax.plot([cell.rb[0], cell.rt[0]], [cell.rb[1], cell.rt[1]])\n                if cell.top:\n                    ax.plot([cell.lt[0], cell.rt[0]], [cell.lt[1], cell.rt[1]])\n                if cell.bottom:\n                    ax.plot([cell.lb[0], cell.rb[0]], [cell.lb[1], cell.rb[1]])\n        return fig\n\n    def contour(self, table):\n        \"\"\"Generates a plot for all table boundaries present\n        on the PDF page.\n\n        Parameters\n        ----------\n        table : camelot.core.Table\n\n        Returns\n        -------\n        fig : matplotlib.fig.Figure\n\n        \"\"\"\n        try:\n            img, table_bbox = table._image\n            _FOR_LATTICE = True\n        except TypeError:\n            img, table_bbox = (None, {table._bbox: None})\n            _FOR_LATTICE = False\n        fig = plt.figure()\n        ax = fig.add_subplot(111, aspect=\"equal\")\n\n        xs, ys = [], []\n        if not _FOR_LATTICE:\n            for t in table._text:\n                xs.extend([t[0], t[2]])\n                ys.extend([t[1], t[3]])\n                ax.add_patch(\n                    patches.Rectangle(\n                        (t[0], t[1]), t[2] - t[0], t[3] - t[1], color=\"blue\"\n                    )\n                )\n\n        for t in table_bbox.keys():\n            ax.add_patch(\n                patches.Rectangle(\n                    (t[0], t[1]), t[2] - t[0], t[3] - t[1], fill=False, color=\"red\"\n                )\n            )\n            if not _FOR_LATTICE:\n                xs.extend([t[0], t[2]])\n                ys.extend([t[1], t[3]])\n                ax.set_xlim(min(xs) - 10, max(xs) + 10)\n                ax.set_ylim(min(ys) - 10, max(ys) + 10)\n\n        if _FOR_LATTICE:\n            ax.imshow(img)\n        return fig\n\n    def textedge(self, table):\n        \"\"\"Generates a plot for relevant textedges.\n\n        Parameters\n        ----------\n        table : camelot.core.Table\n\n        Returns\n        -------\n        fig : matplotlib.fig.Figure\n\n        \"\"\"\n        fig = plt.figure()\n        ax = fig.add_subplot(111, aspect=\"equal\")\n        xs, ys = [], []\n        for t in table._text:\n            xs.extend([t[0], t[2]])\n            ys.extend([t[1], t[3]])\n            ax.add_patch(\n                patches.Rectangle((t[0], t[1]), t[2] - t[0], t[3] - t[1], color=\"blue\")\n            )\n        ax.set_xlim(min(xs) - 10, max(xs) + 10)\n        ax.set_ylim(min(ys) - 10, max(ys) + 10)\n\n        for te in table._textedges:\n            ax.plot([te.x, te.x], [te.y0, te.y1])\n\n        return fig\n\n    def joint(self, table):\n        \"\"\"Generates a plot for all line intersections present\n        on the PDF page.\n\n        Parameters\n        ----------\n        table : camelot.core.Table\n\n        Returns\n        -------\n        fig : matplotlib.fig.Figure\n\n        \"\"\"\n        img, table_bbox = table._image\n        fig = plt.figure()\n        ax = fig.add_subplot(111, aspect=\"equal\")\n        x_coord = []\n        y_coord = []\n        for k in table_bbox.keys():\n            for coord in table_bbox[k]:\n                x_coord.append(coord[0])\n                y_coord.append(coord[1])\n        ax.plot(x_coord, y_coord, \"ro\")\n        ax.imshow(img)\n        return fig\n\n    def line(self, table):\n        \"\"\"Generates a plot for all line segments present\n        on the PDF page.\n\n        Parameters\n        ----------\n        table : camelot.core.Table\n\n        Returns\n        -------\n        fig : matplotlib.fig.Figure\n\n        \"\"\"\n        fig = plt.figure()\n        ax = fig.add_subplot(111, aspect=\"equal\")\n        vertical, horizontal = table._segments\n        for v in vertical:\n            ax.plot([v[0], v[2]], [v[1], v[3]])\n        for h in horizontal:\n            ax.plot([h[0], h[2]], [h[1], h[3]])\n        return fig\n</code></pre>"},{"location":"api/#camelot.plotting.PlotMethods.__call__","title":"camelot.plotting.PlotMethods.__call__","text":"<pre><code>__call__(table, kind='text', filename=None)\n</code></pre> <p>Plot elements found on PDF page based on kind specified, useful for debugging and playing with different parameters to get the best output.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <p>A Camelot Table.</p> required <code>kind</code> <code>str, optional (default: 'text')</code> <p>{'text', 'grid', 'contour', 'joint', 'line'} The element type for which a plot should be generated.</p> <code>'text'</code> <code>filepath</code> <p>Absolute path for saving the generated plot.</p> required <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> Source code in <code>camelot/plotting.py</code> <pre><code>def __call__(self, table, kind=\"text\", filename=None):\n    \"\"\"Plot elements found on PDF page based on kind\n    specified, useful for debugging and playing with different\n    parameters to get the best output.\n\n    Parameters\n    ----------\n    table: camelot.core.Table\n        A Camelot Table.\n    kind : str, optional (default: 'text')\n        {'text', 'grid', 'contour', 'joint', 'line'}\n        The element type for which a plot should be generated.\n    filepath: str, optional (default: None)\n        Absolute path for saving the generated plot.\n\n    Returns\n    -------\n    fig : matplotlib.fig.Figure\n\n    \"\"\"\n    if not _HAS_MPL:\n        raise ImportError(\"matplotlib is required for plotting.\")\n\n    if table.flavor == \"lattice\" and kind in [\"textedge\"]:\n        raise NotImplementedError(f\"Lattice flavor does not support kind='{kind}'\")\n    elif table.flavor == \"stream\" and kind in [\"joint\", \"line\"]:\n        raise NotImplementedError(f\"Stream flavor does not support kind='{kind}'\")\n\n    plot_method = getattr(self, kind)\n    fig = plot_method(table)\n\n    if filename is not None:\n        fig.savefig(filename)\n        return None\n\n    return fig\n</code></pre>"},{"location":"api/#camelot.plotting.PlotMethods.contour","title":"camelot.plotting.PlotMethods.contour","text":"<pre><code>contour(table)\n</code></pre> <p>Generates a plot for all table boundaries present on the PDF page.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>Table</code> required <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> Source code in <code>camelot/plotting.py</code> <pre><code>def contour(self, table):\n    \"\"\"Generates a plot for all table boundaries present\n    on the PDF page.\n\n    Parameters\n    ----------\n    table : camelot.core.Table\n\n    Returns\n    -------\n    fig : matplotlib.fig.Figure\n\n    \"\"\"\n    try:\n        img, table_bbox = table._image\n        _FOR_LATTICE = True\n    except TypeError:\n        img, table_bbox = (None, {table._bbox: None})\n        _FOR_LATTICE = False\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n\n    xs, ys = [], []\n    if not _FOR_LATTICE:\n        for t in table._text:\n            xs.extend([t[0], t[2]])\n            ys.extend([t[1], t[3]])\n            ax.add_patch(\n                patches.Rectangle(\n                    (t[0], t[1]), t[2] - t[0], t[3] - t[1], color=\"blue\"\n                )\n            )\n\n    for t in table_bbox.keys():\n        ax.add_patch(\n            patches.Rectangle(\n                (t[0], t[1]), t[2] - t[0], t[3] - t[1], fill=False, color=\"red\"\n            )\n        )\n        if not _FOR_LATTICE:\n            xs.extend([t[0], t[2]])\n            ys.extend([t[1], t[3]])\n            ax.set_xlim(min(xs) - 10, max(xs) + 10)\n            ax.set_ylim(min(ys) - 10, max(ys) + 10)\n\n    if _FOR_LATTICE:\n        ax.imshow(img)\n    return fig\n</code></pre>"},{"location":"api/#camelot.plotting.PlotMethods.grid","title":"camelot.plotting.PlotMethods.grid","text":"<pre><code>grid(table)\n</code></pre> <p>Generates a plot for the detected table grids on the PDF page.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>Table</code> required <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> Source code in <code>camelot/plotting.py</code> <pre><code>def grid(self, table):\n    \"\"\"Generates a plot for the detected table grids\n    on the PDF page.\n\n    Parameters\n    ----------\n    table : camelot.core.Table\n\n    Returns\n    -------\n    fig : matplotlib.fig.Figure\n\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n    for row in table.cells:\n        for cell in row:\n            if cell.left:\n                ax.plot([cell.lb[0], cell.lt[0]], [cell.lb[1], cell.lt[1]])\n            if cell.right:\n                ax.plot([cell.rb[0], cell.rt[0]], [cell.rb[1], cell.rt[1]])\n            if cell.top:\n                ax.plot([cell.lt[0], cell.rt[0]], [cell.lt[1], cell.rt[1]])\n            if cell.bottom:\n                ax.plot([cell.lb[0], cell.rb[0]], [cell.lb[1], cell.rb[1]])\n    return fig\n</code></pre>"},{"location":"api/#camelot.plotting.PlotMethods.joint","title":"camelot.plotting.PlotMethods.joint","text":"<pre><code>joint(table)\n</code></pre> <p>Generates a plot for all line intersections present on the PDF page.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>Table</code> required <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> Source code in <code>camelot/plotting.py</code> <pre><code>def joint(self, table):\n    \"\"\"Generates a plot for all line intersections present\n    on the PDF page.\n\n    Parameters\n    ----------\n    table : camelot.core.Table\n\n    Returns\n    -------\n    fig : matplotlib.fig.Figure\n\n    \"\"\"\n    img, table_bbox = table._image\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n    x_coord = []\n    y_coord = []\n    for k in table_bbox.keys():\n        for coord in table_bbox[k]:\n            x_coord.append(coord[0])\n            y_coord.append(coord[1])\n    ax.plot(x_coord, y_coord, \"ro\")\n    ax.imshow(img)\n    return fig\n</code></pre>"},{"location":"api/#camelot.plotting.PlotMethods.line","title":"camelot.plotting.PlotMethods.line","text":"<pre><code>line(table)\n</code></pre> <p>Generates a plot for all line segments present on the PDF page.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>Table</code> required <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> Source code in <code>camelot/plotting.py</code> <pre><code>def line(self, table):\n    \"\"\"Generates a plot for all line segments present\n    on the PDF page.\n\n    Parameters\n    ----------\n    table : camelot.core.Table\n\n    Returns\n    -------\n    fig : matplotlib.fig.Figure\n\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n    vertical, horizontal = table._segments\n    for v in vertical:\n        ax.plot([v[0], v[2]], [v[1], v[3]])\n    for h in horizontal:\n        ax.plot([h[0], h[2]], [h[1], h[3]])\n    return fig\n</code></pre>"},{"location":"api/#camelot.plotting.PlotMethods.text","title":"camelot.plotting.PlotMethods.text","text":"<pre><code>text(table)\n</code></pre> <p>Generates a plot for all text elements present on the PDF page.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>Table</code> required <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> Source code in <code>camelot/plotting.py</code> <pre><code>def text(self, table):\n    \"\"\"Generates a plot for all text elements present\n    on the PDF page.\n\n    Parameters\n    ----------\n    table : camelot.core.Table\n\n    Returns\n    -------\n    fig : matplotlib.fig.Figure\n\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n    xs, ys = [], []\n    for t in table._text:\n        xs.extend([t[0], t[2]])\n        ys.extend([t[1], t[3]])\n        ax.add_patch(patches.Rectangle((t[0], t[1]), t[2] - t[0], t[3] - t[1]))\n    ax.set_xlim(min(xs) - 10, max(xs) + 10)\n    ax.set_ylim(min(ys) - 10, max(ys) + 10)\n    return fig\n</code></pre>"},{"location":"api/#camelot.plotting.PlotMethods.textedge","title":"camelot.plotting.PlotMethods.textedge","text":"<pre><code>textedge(table)\n</code></pre> <p>Generates a plot for relevant textedges.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>Table</code> required <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> Source code in <code>camelot/plotting.py</code> <pre><code>def textedge(self, table):\n    \"\"\"Generates a plot for relevant textedges.\n\n    Parameters\n    ----------\n    table : camelot.core.Table\n\n    Returns\n    -------\n    fig : matplotlib.fig.Figure\n\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n    xs, ys = [], []\n    for t in table._text:\n        xs.extend([t[0], t[2]])\n        ys.extend([t[1], t[3]])\n        ax.add_patch(\n            patches.Rectangle((t[0], t[1]), t[2] - t[0], t[3] - t[1], color=\"blue\")\n        )\n    ax.set_xlim(min(xs) - 10, max(xs) + 10)\n    ax.set_ylim(min(ys) - 10, max(ys) + 10)\n\n    for te in table._textedges:\n        ax.plot([te.x, te.x], [te.y0, te.y1])\n\n    return fig\n</code></pre>"},{"location":"developers/contributing/","title":"Contributor Guide","text":"<p>If you're reading this, you're probably looking to contributing to Camelot. Time is the only real currency, and the fact that you're considering spending some here is very generous of you. Thank you very much!</p> <p>This document will help you get started with contributing documentation, code, testing and filing issues. If you have any questions, feel free to reach out to Vinayak Mehta, the author and maintainer.</p>"},{"location":"developers/contributing/#code-of-conduct","title":"Code Of Conduct","text":"<p>The following quote sums up the Code Of Conduct:</p> <p>Be cordial or be on your way. --Kenneth Reitz</p> <p>Kenneth Reitz has also written an essay on this topic, which you should read.</p> <p>As the Requests Code Of Conduct states, all contributions are welcome, as long as everyone involved is treated with respect.</p>"},{"location":"developers/contributing/#your-first-contribution","title":"Your first contribution","text":"<p>A great way to start contributing to Camelot is to pick an issue tagged with the help wanted or the good first issue tags. If you're unable to find a good first issue, feel free to contact the maintainer.</p>"},{"location":"developers/contributing/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>To install the dependencies needed for development, you can use pip::</p> <pre><code>    $ pip install \"camelot-py[dev]\"\n</code></pre> <p>Alternatively, you can clone the project repository, and install using pip::</p> <pre><code>    $ pip install \".[dev]\"\n</code></pre>"},{"location":"developers/contributing/#pull-requests","title":"Pull Requests","text":""},{"location":"developers/contributing/#submit-a-pull-request","title":"Submit a pull request","text":"<p>The preferred workflow for contributing to Camelot is to fork the project repository on GitHub, clone, develop on a branch and then finally submit a pull request. Here are the steps:</p> <ol> <li> <p>Fork the project repository. Click on the \u2018Fork\u2019 button near the top of the page. This creates a copy of the code under your account on the GitHub.</p> </li> <li> <p>Clone your fork of Camelot from your GitHub account::</p> <pre><code>$ git clone https://www.github.com/[username]/camelot\n</code></pre> </li> <li> <p>Create a branch to hold your changes::</p> <pre><code>$ git checkout -b my-feature\n</code></pre> </li> </ol> <p>Always branch out from <code>master</code> to work on your contribution. It's good practice to never work on the <code>master</code> branch!</p> <p>Note</p> <p><code>git stash</code> is a great way to save the work that you haven't committed yet, to move between branches.</p> <ol> <li>Work on your contribution. Add changed files using <code>git add</code> and then <code>git commit</code> them::</li> </ol> <pre><code>    $ git add modified_files\n    $ git commit\n</code></pre> <ol> <li>Finally, push them to your GitHub fork::</li> </ol> <pre><code>    $ git push -u origin my-feature\n</code></pre> <p>Now it's time to go to the your fork of Camelot and create a pull request! You can follow these instructions to do the same.</p>"},{"location":"developers/contributing/#work-on-your-pull-request","title":"Work on your pull request","text":"<p>We recommend that your pull request complies with the following guidelines:</p> <ul> <li> <p>Make sure your code follows PEP 8.</p> </li> <li> <p>In case your pull request contains function docstrings, make sure you follow the numpydoc format. All function docstrings in Camelot follow this format. Following the format will make sure that the API documentation is generated flawlessly.</p> </li> <li> <p>Make sure your commit messages follow the seven rules of a great git commit message:</p> <ul> <li>Separate subject from body with a blank line</li> <li>Limit the subject line to 50 characters</li> <li>Capitalize the subject line</li> <li>Do not end the subject line with a period</li> <li>Use the imperative mood in the subject line</li> <li>Wrap the body at 72 characters</li> <li>Use the body to explain what and why vs. how</li> </ul> </li> <li> <p>Please prefix your title of your pull request with [MRG] (Ready for Merge), if the contribution is complete and ready for a detailed review. An incomplete pull request's title should be prefixed with [WIP] (to indicate a work in progress), and changed to [MRG] when it's complete. A good task list in the PR description will ensure that other people get a fair idea of what it proposes to do, which will also increase collaboration.</p> </li> <li> <p>If contributing new functionality, make sure that you add a unit test for it, while making sure that all previous tests pass. Camelot uses pytest for testing. Tests can be run using:</p> </li> </ul> <pre><code>$ python setup.py test\n</code></pre>"},{"location":"developers/contributing/#writing-documentation","title":"Writing Documentation","text":"<p>Writing documentation, function docstrings, examples and tutorials is a great way to start contributing to open-source software! The documentation is present inside the <code>docs/</code> directory of the source code repository.</p> <p>The documentation is written in markdown, with Material for Mkdocs used to generate these lovely HTML files that you're currently reading (unless you're reading this on GitHub). You can edit the documentation using any text editor and then generate the HTML output by running <code>mkdocs serve</code> or <code>mkdocs build</code> in the <code>docs/</code> directory. GitHub Actions trigger an update of the online documentation automatically.</p> <p>The function docstrings are written using the mkdocstrings extension for Material for Mkdocs. Make sure you check out its format guidelines before you start writing docstrings.</p> <p>Note</p> <p>Installation steps for <code>Material for Mkdocs</code> to be added shortly.</p>"},{"location":"developers/contributing/#filing-issues","title":"Filing Issues","text":"<p>We use GitHub issues to keep track of all issues and pull requests. Before opening an issue (which asks a question or reports a bug), please use GitHub search to look for existing issues (both open and closed) that may be similar.</p>"},{"location":"developers/contributing/#questions","title":"Questions","text":"<p>Please don't use GitHub issues for support questions. A better place for them would be Stack Overflow. Make sure you tag them using the <code>python-camelot</code> tag.</p>"},{"location":"developers/contributing/#bug-reports","title":"Bug Reports","text":"<p>In bug reports, make sure you include:</p> <ul> <li>Your operating system type and Python version number, along with the version numbers of NumPy, OpenCV and Camelot. You can use the following code snippet to find this information:</li> </ul> <pre><code>    import platform; print(platform.platform())\n    import sys; print('Python', sys.version)\n    import numpy; print('NumPy', numpy.__version__)\n    import cv2; print('OpenCV', cv2.__version__)\n    import camelot; print('Camelot', camelot.__version__)\n</code></pre> <ul> <li> <p>The complete traceback. Just adding the exception message or a part of the traceback won't help us fix your issue sooner.</p> </li> <li> <p>Steps to reproduce the bug, using code snippets. See Creating and highlighting code blocks.</p> </li> <li> <p>A link to the PDF document that you were trying to extract tables from, telling us what you expected the code to do and what actually happened.</p> </li> </ul>"},{"location":"user_guide/advanced/","title":"Advanced Usage","text":"<p>This page covers some of the more advanced configurations for Lattice and Stream.</p>"},{"location":"user_guide/advanced/#process-background-lines","title":"Process background lines","text":"<p>To detect line segments, Lattice needs the lines that make the table to be in the foreground. Here's an example of a table with lines in the background:</p> <p> </p> A table with lines in background <p>Source: PDF</p> <p>To process background lines, you can pass <code>process_background=True</code>.</p> <pre><code>tables = camelot.read_pdf('background_lines.pdf', process_background=True)\ntables[1].df\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot lattice -back background_lines.pdf\n</code></pre> State Date Halt stations Halt days Persons directly reached(in lakh) Persons trained Persons counseled Persons testedfor HIV Delhi 1.12.2009 8 17 1.29 3,665 2,409 1,000 Rajasthan 2.12.2009 to 19.12.2009 nan nan nan nan nan nan Gujarat 20.12.2009 to 3.1.2010 6 13 6.03 3,810 2,317 1,453 Maharashtra 4.01.2010 to 1.2.2010 13 26 1.27 5,680 9,027 4,153 Karnataka 2.2.2010 to 22.2.2010 11 19 1.8 5,741 3,658 3,183 Kerala 23.2.2010 to 11.3.2010 9 17 1.42 3,559 2,173 855 Total nan 47 92 11.81 22,455 19,584 10,644"},{"location":"user_guide/advanced/#visual-debugging","title":"Visual debugging","text":"<p>Note</p> <p>Visual debugging using <code>plot()</code> requires matplotlib which is an optional dependency. You can install it using <code>$ pip install camelot-py[plot]</code>.</p> <p>You can use the plot() method to generate a <code>matplotlib &lt;https://matplotlib.org/&gt;</code>_ plot of various elements that were detected on the PDF page while processing it. This can help you select table areas, column separators and debug bad table outputs, by tweaking different configuration parameters.</p> <p>You can specify the type of element you want to plot using the <code>kind</code> keyword argument. The generated plot can be saved to a file by passing a <code>filename</code> keyword argument. The following plot types are supported:</p> <ul> <li>'text'</li> <li>'grid'</li> <li>'contour'</li> <li>'line'</li> <li>'joint'</li> <li>'textedge'</li> </ul> <p>Note</p> <p>'line' and 'joint' can only be used with Lattice and 'textedge' can only be used with Stream.</p> <p>Let's generate a plot for each type using this PDF as an example. First, let's get all the tables out.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('foo.pdf')\n&gt;&gt;&gt; tables\n&lt;TableList n=1&gt;\n</code></pre>"},{"location":"user_guide/advanced/#text","title":"text","text":"<p>Let's plot all the text present on the table's PDF page.</p> <pre><code>&gt;&gt;&gt; camelot.plot(tables[0], kind='text').show()\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot lattice -plot text foo.pdf\n</code></pre> <p> </p> A plot of all text on a PDF page <p>This, as we shall later see, is very helpful with Stream for noting table areas and column separators, in case Stream does not guess them correctly.</p> <p>Note</p> <p>The x-y coordinates shown above change as you move your mouse cursor on the image, which can help you note coordinates.</p>"},{"location":"user_guide/advanced/#table","title":"table","text":"<p>Let's plot the table (to see if it was detected correctly or not). This plot type, along with contour, line and joint is useful for debugging and improving the extraction output, in case the table wasn't detected correctly. (More on that later.)</p> <pre><code>&gt;&gt;&gt; camelot.plot(tables[0], kind='grid').show()\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot lattice -plot grid foo.pdf\n</code></pre> <p> </p> A plot of all tables on a PDF page <p>The table is perfect!</p>"},{"location":"user_guide/advanced/#contour","title":"contour","text":"<p>Now, let's plot all table boundaries present on the table's PDF page.</p> <pre><code>&gt;&gt;&gt; camelot.plot(tables[0], kind='contour').show()\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>    $ camelot lattice -plot contour foo.pdf\n</code></pre> <p> </p> A plot of all contours on a PDF page"},{"location":"user_guide/advanced/#line","title":"line","text":"<p>Cool, let's plot all line segments present on the table's PDF page.</p> <pre><code>&gt;&gt;&gt; camelot.plot(tables[0], kind='line').show()\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>    $ camelot lattice -plot line foo.pdf\n</code></pre> <p> </p> A plot of all lines on a PDF page"},{"location":"user_guide/advanced/#joint","title":"joint","text":"<p>Finally, let's plot all line intersections present on the table's PDF page.</p> <pre><code>&gt;&gt;&gt; camelot.plot(tables[0], kind='joint').show()\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot lattice -plot joint foo.pdf\n</code></pre> <p> </p> A plot of all line intersections on a PDF page"},{"location":"user_guide/advanced/#textedge","title":"textedge","text":"<p>You can also visualize the textedges found on a page by specifying <code>kind='textedge'</code>. To know more about what a \"textedge\" is, you can see pages 20, 35 and 40 of Anssi Nurminen's master's thesis.</p> <pre><code>&gt;&gt;&gt; camelot.plot(tables[0], kind='textedge').show()\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot stream -plot textedge foo.pdf\n</code></pre> <p> </p> A plot of relevant textedges on a PDF page"},{"location":"user_guide/advanced/#specify-table-areas","title":"Specify table areas","text":"<p>In cases such as these, it can be useful to specify exact table boundaries. You can plot the text on this page and note the top left and bottom right coordinates of the table.</p> <p>Table areas that you want Camelot to analyze can be passed as a list of comma-separated strings to :meth:<code>read_pdf() &lt;camelot.read_pdf&gt;</code>, using the <code>table_areas</code> keyword argument.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('table_areas.pdf', flavor='stream', table_areas=['316,499,566,337'])\n&gt;&gt;&gt; tables[0].df\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot stream -T 316,499,566,337 table_areas.pdf\n</code></pre> Unnamed: 0 One Withholding Payroll Period Allowance Weekly $71.15 Biweekly 142.31 Semimonthly 154.17 Monthly 308.33 Quarterly 925.00 Semiannually 1,850.00 Annually 3,700.00 Daily or Miscellaneous 14.23 (each day of the payroll period) nan <p>Note</p> <p><code>table_areas</code> accepts strings of the form x1,y1,x2,y2 where (x1, y1) -&gt; top-left and (x2, y2) -&gt; bottom-right in PDF coordinate space. In PDF coordinate space, the bottom-left corner of the page is the origin, with coordinates (0, 0).</p>"},{"location":"user_guide/advanced/#specify-table-regions","title":"Specify table regions","text":"<p>However there may be cases like 1 and 2, where the table might not lie at the exact coordinates every time but in an approximate region.</p> <p>You can use the <code>table_regions</code> keyword argument to read_pdf() to solve for such cases. When <code>table_regions</code> is specified, Camelot will only analyze the specified regions to look for tables.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('table_regions.pdf', table_regions=['170,370,560,270'])\n&gt;&gt;&gt; tables[0].df\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot lattice -R 170,370,560,270 table_regions.pdf\n</code></pre> Et\u00e0 dell\u2019Assicuratoall\u2019epoca del decesso Misura % dimaggiorazione 18-75 1,00% 76-80 0,50% 81 in poi 0,10%"},{"location":"user_guide/advanced/#specify-column-separators","title":"Specify column separators","text":"<p>In cases like these, where the text is very close to each other, it is possible that Camelot may guess the column separators' coordinates incorrectly. To correct this, you can explicitly specify the x coordinate for each column separator by plotting the text on the page.</p> <p>You can pass the column separators as a list of comma-separated strings to :meth:<code>read_pdf() &lt;camelot.read_pdf&gt;</code>, using the <code>columns</code> keyword argument.</p> <p>In case you passed a single column separators string list, and no table area is specified, the separators will be applied to the whole page. When a list of table areas is specified and you need to specify column separators as well, the length of both lists should be equal. Each table area will be mapped to each column separators' string using their indices.</p> <p>For example, if you have specified two table areas, <code>table_areas=['12,54,43,23', '20,67,55,33']</code>, and only want to specify column separators for the first table, you can pass an empty string for the second table in the column separators' list like this, <code>columns=['10,120,200,400', '']</code>.</p> <p>Let's get back to the x coordinates we got from plotting the text that exists on this PDF, and get the table out!</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('column_separators.pdf', flavor='stream', columns=['72,95,209,327,442,529,566,606,683'])\n&gt;&gt;&gt; tables[0].df\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot stream -C 72,95,209,327,442,529,566,606,683 column_separators.pdf\n</code></pre> ... ... ... ... ... ... ... ... ... ... LICENSE PREMISE NUMBER TYPE DBA NAME LICENSEE NAME ADDRESS CITY ST ZIP PHONE NUMBER EXPIRES ... ... ... ... ... ... ... ... ... ... <p>Ah! Since PDFMiner merged the strings, \"NUMBER\", \"TYPE\" and \"DBA NAME\", all of them were assigned to the same cell. Let's see how we can fix this in the next section.</p>"},{"location":"user_guide/advanced/#split-text-along-separators","title":"Split text along separators","text":"<p>To deal with cases like the output from the previous section, you can pass <code>split_text=True</code> to :meth:<code>read_pdf() &lt;camelot.read_pdf&gt;</code>, which will split any strings that lie in different cells but have been assigned to a single cell (as a result of being merged together by PDFMiner).</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('column_separators.pdf', flavor='stream', columns=['72,95,209,327,442,529,566,606,683'], split_text=True)\n&gt;&gt;&gt; tables[0].df\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot -split stream -C 72,95,209,327,442,529,566,606,683 column_separators.pdf\n</code></pre> ... ... ... ... ... ... ... ... ... ... LICENSE PREMISE NUMBER TYPE DBA NAME LICENSEE NAME ADDRESS CITY ST ZIP PHONE NUMBER EXPIRES ... ... ... ... ... ... ... ... ... ..."},{"location":"user_guide/advanced/#flag-superscripts-and-subscripts","title":"Flag superscripts and subscripts","text":"<p>There might be cases where you want to differentiate between the text and superscripts or subscripts, like this PDF.</p> <p> </p> A PDF with superscripts <p>In this case, the text that other tools return, will be <code>24.912</code>. This is relatively harmless when that decimal point is involved. But when it isn't there, you'll be left wondering why the results of your data analysis are 10x bigger!</p> <p>You can solve this by passing <code>flag_size=True</code>, which will enclose the superscripts and subscripts with <code>&lt;s&gt;&lt;/s&gt;</code>, based on font size, as shown below.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('superscript.pdf', flavor='stream', flag_size=True)\n&gt;&gt;&gt; tables[0].df\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot -flag stream superscript.pdf\n</code></pre> ... ... ... ... ... ... ... ... ... ... ... Karnataka 22.44 19.59 - - 2.86 1.22 - 0.89 - 0.69 Kerala 29.03 24.91<sup>2</sup> - - 4.11 1.77 - 0.48 - 1.45 Madhya Pradesh 27.13 23.57 - - 3.56 0.38 - 1.86 - 1.28 ... ... ... ... ... ... ... ... ... ... ..."},{"location":"user_guide/advanced/#strip-characters-from-text","title":"Strip characters from text","text":"<p>You can strip unwanted characters like spaces, dots and newlines from a string using the <code>strip_text</code> keyword argument. Take a look at <code>this PDF &lt;https://github.com/camelot-dev/camelot/blob/master/tests/files/tabula/12s0324.pdf&gt;</code>_ as an example, the text at the start of each row contains a lot of unwanted spaces, dots and newlines.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('12s0324.pdf', flavor='stream', strip_text=' .\\n')\n&gt;&gt;&gt; tables[0].df\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot -strip ' .\\n' stream 12s0324.pdf\n</code></pre> ... ... ... ... ... ... ... ... ... ... Forcible rape 17.5 2.6 14.9 17.2 2.5 14.7 \u2013 \u2013 \u2013 Robbery 102.1 25.5 76.6 90.0 22.9 67.1 12.1 2.5 9.5 Aggravated assault 338.4 40.1 298.3 264.0 30.2 233.8 74.4 9.9 64.5 Property crime 1,396 .4 338 .7 1,057 .7 875 .9 210 .8 665 .1 608 .2 127 .9 392 .6 Burglary 240.9 60.3 180.6 205.0 53.4 151.7 35.9 6.9 29.0 ... ... ... ... ... ... ... ... ... ..."},{"location":"user_guide/advanced/#improve-guessed-table-areas","title":"Improve guessed table areas","text":"<p>While using Stream, automatic table detection can fail for PDFs like this one. That's because the text is relatively far apart vertically, which can lead to shorter textedges being calculated.</p> <p>Note</p> <p>To know more about how textedges are calculated to guess table areas, you can see pages 20, 35 and 40 of Anssi Nurminen's master's thesis.</p> <p>Let's see the table area that is detected by default.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('edge_tol.pdf', flavor='stream')\n&gt;&gt;&gt; camelot.plot(tables[0], kind='contour').show()\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot stream -plot contour edge.pdf\n</code></pre> <p> </p> Table area with default edge_tol <p>To improve the detected area, you can increase the <code>edge_tol</code> (default: 50) value to counter the effect of text being placed relatively far apart vertically. Larger <code>edge_tol</code> will lead to longer textedges being detected, leading to an improved guess of the table area. Let's use a value of 500.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('edge_tol.pdf', flavor='stream', edge_tol=500)\n&gt;&gt;&gt; camelot.plot(tables[0], kind='contour').show()\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot stream -e 500 -plot contour edge.pdf\n</code></pre> <p> </p> Table area with default edge_tol <p>As you can see, the guessed table area has improved!</p>"},{"location":"user_guide/advanced/#improve-guessed-table-rows","title":"Improve guessed table rows","text":"<p>You can pass <code>row_tol=&lt;+int&gt;</code> to group the rows closer together, as shown below.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('group_rows.pdf', flavor='stream')\n&gt;&gt;&gt; tables[0].df\n</code></pre> Clave Clave Clave Nombre Entidad Nombre Municipio Nombre Localidad Entidad Municipio Localidad 01 Aguascalientes 001 Aguascalientes 0094 Granja Adelita 01 Aguascalientes 001 Aguascalientes 0096 Agua Azul 01 Aguascalientes 001 Aguascalientes 0100 Rancho Alegre <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('group_rows.pdf', flavor='stream', row_tol=10)\n&gt;&gt;&gt; tables[0].df\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot stream -r 10 group_rows.pdf\n</code></pre> Clave Nombre Entidad Clave Nombre Municipio Clave Nombre Localidad Entidad Municipio Localidad 01 Aguascalientes 001 Aguascalientes 0094 Granja Adelita 01 Aguascalientes 001 Aguascalientes 0096 Agua Azul 01 Aguascalientes 001 Aguascalientes 0100 Rancho Alegre"},{"location":"user_guide/advanced/#detect-short-lines","title":"Detect short lines","text":"<p>There might be cases while using Lattice when smaller lines don't get detected. The size of the smallest line that gets detected is calculated by dividing the PDF page's dimensions with a scaling factor called <code>line_scale</code>. By default, its value is 15.</p> <p>As you can guess, the larger the <code>line_scale</code>, the smaller the size of lines getting detected.</p> <p>.. warning:: Making <code>line_scale</code> very large (&gt;150) will lead to text getting detected as lines.</p> <p>Here's a PDF where small lines separating the the headers don't get detected with the default value of 15.</p> <p> </p> A PDF table with short lines <p>Let's plot the table for this PDF.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('short_lines.pdf')\n&gt;&gt;&gt; camelot.plot(tables[0], kind='grid').show()\n</code></pre> <p> </p> A plot of the PDF table with short lines <p>Clearly, the smaller lines separating the headers, couldn't be detected. Let's try with <code>line_scale=40</code>, and plot the table again.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('short_lines.pdf', line_scale=40)\n&gt;&gt;&gt; camelot.plot(tables[0], kind='grid').show()\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot lattice -scale 40 -plot grid short_lines.pdf\n</code></pre> <p></p> <p> </p> An improved plot of the PDF table with short lines <p>Voila! Camelot can now see those lines. Let's get our table.</p> <pre><code>&gt;&gt;&gt; tables[0].df\n</code></pre> Investigations No. ofHHs Age/Sex/Physiological  Group Preva-lence C.I* RelativePrecision Sample sizeper State Anthropometry 2400 All ... Clinical Examination History of morbidity Diet survey 1200 All ... Blood Pressure # 2400 Men (\u2265 18yrs) 10% 95% 20% 1728 Women (\u2265 18 yrs) 1728 Fasting blood glucose 2400 Men (\u2265 18 yrs) 5% 95% 20% 1825 Women (\u2265 18 yrs) 1825 Knowledge &amp;Practices on HTN &amp;DM 2400 Men (\u2265 18 yrs) - - - 1728 2400 Women (\u2265 18 yrs) - - - 1728"},{"location":"user_guide/advanced/#shift-text-in-spanning-cells","title":"Shift text in spanning cells","text":"<p>By default, the Lattice method shifts text in spanning cells, first to the left and then to the top, as you can observe in the output table above. However, this behavior can be changed using the <code>shift_text</code> keyword argument. Think of it as setting the gravity for a table \u2014 it decides the direction in which the text will move and finally come to rest.</p> <p><code>shift_text</code> expects a list with one or more characters from the following set: <code>('', l', 'r', 't', 'b')</code>, which are then applied in order. The default, as we discussed above, is <code>['l', 't']</code>.</p> <p>We'll use the PDF from the previous example. Let's pass <code>shift_text=['']</code>, which basically means that the text will experience weightlessness! (It will remain in place.)</p> <p> </p> A PDF table with short lines <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('short_lines.pdf', line_scale=40, shift_text=[''])\n&gt;&gt;&gt; tables[0].df\n</code></pre> Investigations No. ofHHs Age/Sex/Physiological  Group Preva-lence C.I* RelativePrecision Sample sizeper State Anthropometry Clinical Examination 2400 All ... History of morbidity Diet survey 1200 All ... Men (\u2265 18yrs) 1728 Blood Pressure # 2400 Women (\u2265 18 yrs) 10% 95% 20% 1728 Men (\u2265 18 yrs) 1825 Fasting blood glucose 2400 Women (\u2265 18 yrs) 5% 95% 20% 1825 Knowledge &amp;Practices on HTN &amp; 2400 Men (\u2265 18 yrs) - - - 1728 DM 2400 Women (\u2265 18 yrs) - - - 1728 <p>No surprises there \u2014 it did remain in place (observe the strings \"2400\" and \"All the available individuals\"). Let's pass <code>shift_text=['r', 'b']</code> to set the gravity to right-bottom and move the text in that direction.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('short_lines.pdf', line_scale=40, shift_text=['r', 'b'])\n&gt;&gt;&gt; tables[0].df\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot lattice -scale 40 -shift r -shift b short_lines.pdf\n</code></pre> Investigations No. ofHHs Age/Sex/Physiological  Group Preva-lence C.I* RelativePrecision Sample sizeper State Anthropometry Clinical Examination History of morbidity 2400 All ... Diet survey 1200 All ... Men (\u2265 18yrs) 1728 Blood Pressure # 2400 Women (\u2265 18 yrs) 10% 95% 20% 1728 Men (\u2265 18 yrs) 1825 Fasting blood glucose 2400 Women (\u2265 18 yrs) 5% 95% 20% 1825 2400 Men (\u2265 18 yrs) - - - 1728 Knowledge &amp;Practices on HTN &amp;DM 2400 Women (\u2265 18 yrs) - - - 1728"},{"location":"user_guide/advanced/#copy-text-in-spanning-cells","title":"Copy text in spanning cells","text":"<p>You can copy text in spanning cells when using Lattice, in either the horizontal or vertical direction, or both. This behavior is disabled by default.</p> <p><code>copy_text</code> expects a list with one or more characters from the following set: <code>('v', 'h')</code>, which are then applied in order.</p> <p>Let's try it out on this PDF. First, let's check out the output table to see if we need to use any other configuration parameters.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('copy_text.pdf')\n&gt;&gt;&gt; tables[0].df\n</code></pre> Sl. No. Name of State/UT Name of District Disease/ Illness No. of Cases No. of Deaths Date of start of outbreak Date of reporting Current Status ... 1 Kerala Kollam i.  Food Poisoning 19 0 31/12/13 03/01/14 Under control ... 2 Maharashtra Beed i.  Dengue &amp; Chikungunya   i 11 0 03/01/14 04/01/14 Under control ... 3 Odisha Kalahandi iii. Food Poisoning 42 0 02/01/14 03/01/14 Under control ... 4 West Bengal West Medinipur iv. Acute Diarrhoeal Disease 145 0 04/01/14 05/01/14 Under control ... Birbhum v.  Food Poisoning 199 0 31/12/13 31/12/13 Under control ... Howrah vi. Viral Hepatitis A &amp;E 85 0 26/12/13 27/12/13 Under surveillance ... <p>We don't need anything else. Now, let's pass <code>copy_text=['v']</code> to copy text in the vertical direction. This can save you some time by not having to add this step in your cleaning script!</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('copy_text.pdf', copy_text=['v'])\n&gt;&gt;&gt; tables[0].df\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot lattice -copy v copy_text.pdf\n</code></pre> Sl. No. Name of State/UT Name of District Disease/ Illness No. of Cases No. of Deaths Date of start of outbreak Date of reporting Current Status ... 1 Kerala Kollam i.  Food Poisoning 19 0 31/12/13 03/01/14 Under control ... 2 Maharashtra Beed i.  Dengue &amp; Chikungunya   i 11 0 03/01/14 04/01/14 Under control ... 3 Odisha Kalahandi iii. Food Poisoning 42 0 02/01/14 03/01/14 Under control ... 4 West Bengal West Medinipur iv. Acute Diarrhoeal Disease 145 0 04/01/14 05/01/14 Under control ... 4 West Bengal Birbhum v.  Food Poisoning 199 0 31/12/13 31/12/13 Under control ... 4 West Bengal Howrah vi. Viral Hepatitis A &amp;E 85 0 26/12/13 27/12/13 Under surveillance ..."},{"location":"user_guide/advanced/#tweak-layout-generation","title":"Tweak layout generation","text":"<p>Camelot is built on top of PDFMiner's functionality of grouping characters on a page into words and sentences. In some cases (such as #170 and #215), PDFMiner can group characters that should belong to the same sentence into separate sentences.</p> <p>To deal with such cases, you can tweak PDFMiner's LAParams kwargs to improve layout generation, by passing the keyword arguments as a dict using <code>layout_kwargs</code> in read_pdf(). To know more about the parameters you can tweak, you can check out PDFMiner docs.</p> <pre><code>    &gt;&gt;&gt; tables = camelot.read_pdf('foo.pdf', layout_kwargs={'detect_vertical': False})\n</code></pre>"},{"location":"user_guide/advanced/#use-alternate-image-conversion-backends","title":"Use alternate image conversion backends","text":"<p>When using the Lattice flavor, Camelot uses <code>ghostscript</code> to convert PDF pages to images for line recognition. If you face installation issues with <code>ghostscript</code>, you can use an alternate image conversion backend called <code>poppler</code>. You can specify which image conversion backend you want to use with::</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf(filename, backend=\"ghostscript\")  # default\n&gt;&gt;&gt; tables = camelot.read_pdf(filename, backend=\"poppler\")\n</code></pre> <p>Note</p> <p><code>ghostscript</code> will be replaced by <code>poppler</code> as the default image conversion backend in <code>v0.12.0</code>.</p> <p>If you face issues with both <code>ghostscript</code> and <code>poppler</code>, you can supply your own image conversion backend:</p> <pre><code>&gt;&gt;&gt; class ConversionBackend(object):\n&gt;&gt;&gt;     def convert(pdf_path, png_path):\n&gt;&gt;&gt;         # read pdf page from pdf_path\n&gt;&gt;&gt;         # convert pdf page to image\n&gt;&gt;&gt;         # write image to png_path\n&gt;&gt;&gt;         pass\n&gt;&gt;&gt;\n&gt;&gt;&gt; tables = camelot.read_pdf(filename, backend=ConversionBackend())\n</code></pre>"},{"location":"user_guide/cli/","title":"Command-Line Interface","text":"<p>Camelot comes with a command-line interface.</p> <p>You can print the help for the interface by typing <code>camelot --help</code> in your favorite terminal program, as shown below. Furthermore, you can print help for each command by typing <code>camelot &lt;command&gt; --help</code>. Try it out!</p> <pre><code>  Usage: camelot [OPTIONS] COMMAND [ARGS]...\n\n    Camelot: PDF Table Extraction for Humans\n\n  Options:\n    --version                       Show the version and exit.\n    -q, --quiet TEXT                Suppress logs and warnings.\n    -p, --pages TEXT                Comma-separated page numbers. Example: 1,3,4\n                                    or 1,4-end.\n    -pw, --password TEXT            Password for decryption.\n    -o, --output TEXT               Output file path.\n    -f, --format [csv|json|excel|html]\n                                    Output file format.\n    -z, --zip                       Create ZIP archive.\n    -split, --split_text            Split text that spans across multiple cells.\n    -flag, --flag_size              Flag text based on font size. Useful to\n                                    detect super/subscripts.\n    -strip, --strip_text            Characters that should be stripped from a\n                                    string before assigning it to a cell.\n    -M, --margins &lt;FLOAT FLOAT FLOAT&gt;...\n                                    PDFMiner char_margin, line_margin and\n                                    word_margin.\n    --help                          Show this message and exit.\n\n  Commands:\n    lattice  Use lines between text to parse the table.\n    stream   Use spaces between text to parse the table.\n</code></pre>"},{"location":"user_guide/faq/","title":"Frequently Asked Questions","text":"<p>This part of the documentation answers some common questions. To add questions, please open an issue here.</p>"},{"location":"user_guide/faq/#does-camelot-work-with-image-based-pdfs","title":"Does Camelot work with image-based PDFs?","text":"<p>No. Camelot only works with text-based PDFs and not scanned documents. As Tabula explains, \"If you can click and drag to select text in your table in a PDF viewer, then your PDF is text-based\".</p>"},{"location":"user_guide/faq/#how-to-reduce-memory-usage-for-long-pdfs","title":"How to reduce memory usage for long PDFs?","text":"<p>During table extraction from long PDF documents, RAM usage can grow significantly.</p> <p>A simple workaround is to divide the extraction into chunks, and save extracted data to disk at the end of every chunk.</p> <p>For more details, check out this code snippet from <code>@anakin87 &lt;https://github.com/anakin87&gt;</code>_:</p> <pre><code>import camelot\n\n\ndef chunks(l, n):\n    \"\"\"Yield successive n-sized chunks from l.\"\"\"\n    for i in range(0, len(l), n):\n        yield l[i : i + n]\n\n\ndef extract_tables(filepath, pages, chunks=50, export_path=\".\", params={}):\n    \"\"\"\n    Divide the extraction work into n chunks. At the end of every chunk,\n    save data on disk and free RAM.\n\n    filepath : str\n        Filepath or URL of the PDF file.\n    pages : str, optional (default: '1')\n        Comma-separated page numbers.\n        Example: '1,3,4' or '1,4-end' or 'all'.\n    \"\"\"\n\n    # get list of pages from camelot.handlers.PDFHandler\n    handler = camelot.handlers.PDFHandler(filepath)\n    page_list = handler._get_pages(filepath, pages=pages)\n\n    # chunk pages list\n    page_chunks = list(chunks(page_list, chunks))\n\n    # extraction and export\n    for chunk in page_chunks:\n        pages_string = str(chunk).replace(\"[\", \"\").replace(\"]\", \"\")\n        tables = camelot.read_pdf(filepath, pages=pages_string, **params)\n        tables.export(f\"{export_path}/tables.csv\")\n</code></pre>"},{"location":"user_guide/faq/#how-can-i-supply-my-own-image-conversion-backend-to-lattice","title":"How can I supply my own image conversion backend to Lattice?","text":"<p>When using the :ref:<code>Lattice &lt;lattice&gt;</code> flavor, you can supply your own :ref:<code>image conversion backend &lt;image-conversion-backend&gt;</code> by creating a class with a <code>convert</code> method as follows::</p> <pre><code>&gt;&gt;&gt; class ConversionBackend(object):\n&gt;&gt;&gt;     def convert(pdf_path, png_path):\n&gt;&gt;&gt;         # read pdf page from pdf_path\n&gt;&gt;&gt;         # convert pdf page to image\n&gt;&gt;&gt;         # write image to png_path\n&gt;&gt;&gt;         pass\n&gt;&gt;&gt;\n&gt;&gt;&gt; tables = camelot.read_pdf(filename, backend=ConversionBackend())\n</code></pre>"},{"location":"user_guide/how-it-works/","title":"How It Works","text":"<p>This part of the documentation includes a high-level explanation of how Camelot extracts tables from PDF files.</p> <p>You can choose between two table parsing methods, Stream and Lattice. These names for parsing methods inside Camelot were inspired from Tabula.</p>"},{"location":"user_guide/how-it-works/#stream","title":"Stream","text":"<p>Stream can be used to parse tables that have whitespaces between cells to simulate a table structure. It is built on top of PDFMiner's functionality of grouping characters on a page into words and sentences, using margins.</p> <ol> <li> <p>Words on the PDF page are grouped into text rows based on their y axis overlaps.</p> </li> <li> <p>Textedges are calculated and then used to guess interesting table areas on the PDF page. You can read Anssi Nurminen's master's thesis to know more about this table detection technique. [See pages 20, 35 and 40]</p> </li> <li> <p>The number of columns inside each table area are then guessed. This is done by calculating the mode of number of words in each text row. Based on this mode, words in each text row are chosen to calculate a list of column x ranges.</p> </li> <li> <p>Words that lie inside/outside the current column x ranges are then used to extend the current list of columns.</p> </li> <li> <p>Finally, a table is formed using the text rows' y ranges and column x ranges and words found on the page are assigned to the table's cells based on their x and y coordinates.</p> </li> </ol>"},{"location":"user_guide/how-it-works/#lattice","title":"Lattice","text":"<p>Lattice is more deterministic in nature, and it does not rely on guesses. It can be used to parse tables that have demarcated lines between cells, and it can automatically parse multiple tables present on a page.</p> <p>It starts by converting the PDF page to an image using ghostscript, and then processes it to get horizontal and vertical line segments by applying a set of morphological transformations (erosion and dilation) using OpenCV.</p> <p>Let's see how Lattice processes the second page of this PDF, step-by-step.</p> <ol> <li> <p>Line segments are detected. </p> </li> <li> <p>Line intersections are detected, by overlapping the detected line segments and \"and\"ing their pixel intensities. </p> </li> <li> <p>Table boundaries are computed by overlapping the detected line segments again, this time by \"or\"ing their pixel intensities. </p> </li> <li> <p>Since dimensions of the PDF page and its image vary, the detected table boundaries, line intersections, and line segments are scaled and translated to the PDF page's coordinate space, and a representation of the table is created. </p> </li> <li> <p>Spanning cells are detected using the line segments and line intersections. </p> </li> <li> <p>Finally, the words found on the page are assigned to the table's cells based on their x and y coordinates.</p> </li> </ol>"},{"location":"user_guide/install-deps/","title":"Installing Dependencies","text":"<p>The dependencies Ghostscript and Tkinter can be installed using your system's package manager or by running their installer.</p>"},{"location":"user_guide/install-deps/#os-specific-instructions","title":"OS-specific instructions","text":"Linux / MacOSWindows Arch LinuxUbuntuMacOS <pre><code># pacman -S ghostscript tk\n</code></pre> <p>Screencast below illustrates installation for ghostscript only (tkinter was already present)</p> <p> </p> <pre><code>$ apt install ghostscript python3-tk\n</code></pre> <pre><code>$ brew install ghostscript tcl-tk\n</code></pre> <p>For Ghostscript: you can get the installer at their downloads page.</p> <p> </p> <p>For Tkinter: if you installed Python with the standard Python.org installer TCL/Tkinter will typically be installed by default (unless you deselected it).</p> <p>If it is not installed with the standard Python.org installer then the easiest option is to try re-installing Python again, making sure to select it in the options, or you can download the ActiveTcl Community Edition from ActiveState.  If you are using Conda then you can install it into your virtual environment with: <code>conda install -c conda-forge tk</code>.</p>"},{"location":"user_guide/install-deps/#checks-to-see-if-dependencies-are-installed-correctly","title":"Checks to see if dependencies are installed correctly","text":"<p>You can run the following checks to see if the dependencies were installed correctly.</p>"},{"location":"user_guide/install-deps/#for-ghostscript","title":"For Ghostscript","text":"<p>Open the Python REPL and run the following:</p> Linux / MacOSWindows <pre><code>&gt;&gt;&gt; from ctypes.util import find_library\n&gt;&gt;&gt; find_library(\"gs\")\n\"libgs.so.10\"\n</code></pre> <p>Check: The output of the <code>find_library</code> function should not be empty.</p> <p>If the output is empty, then it's possible that the Ghostscript library is not available one of the <code>LD_LIBRARY_PATH</code>/<code>DYLD_LIBRARY_PATH</code> variables depending on your operating system (Linux / MacOS). In this case, you may have to modify one of those path variables to include it.</p> Arch LinuxUbuntu <p> </p> <p>Screencast for Ubuntu coming soon!</p> <pre><code>&gt;&gt;&gt; import ctypes\n&gt;&gt;&gt; from ctypes.util import find_library\n&gt;&gt;&gt; find_library(\"\".join((\"gsdll\", str(ctypes.sizeof(ctypes.c_voidp) * 8), \".dll\")))\n&lt;name-of-ghostscript-library-on-windows&gt;\n</code></pre> <p>Check: The output of the <code>find_library</code> function should not be empty.</p> <p>If the output is empty, then it's possible that the Ghostscript library is not available in the <code>PATH</code> variable on your system. In this case, you may have to modify it to include it.</p> <p> </p>"},{"location":"user_guide/install-deps/#for-tkinter","title":"For Tkinter","text":"<p>Launch Python and then import Tkinter::</p> <pre><code>&gt;&gt;&gt; import tkinter\n</code></pre> <p>Check: Importing <code>tkinter</code> should not raise an import error.</p>"},{"location":"user_guide/install/","title":"Installing Camelot","text":"<p>This part of the documentation covers the steps to install Camelot.</p> <p>After installing the dependencies, which include Ghostscript and Tkinter, you can use one of the following methods to install Camelot:</p> <p>Warning</p> <p>The <code>lattice</code> flavor will fail to run if Ghostscript is not installed. You may run into errors as shown in issue #193.</p>"},{"location":"user_guide/install/#pip","title":"pip","text":"Tip: Use a virtual environment Windows <p>To install Camelot from PyPI using <code>pip</code>, installing without the \"[base]\" option as recommended elsewhere then manually adding opencv-python and ghostscript (note: this refers to the Python package, not the application which should have been installed along with the other dependencies):</p> <pre><code>$ pip install camelot-py\n$ pip install opencv-python\n$ pip install ghostscript\n</code></pre> Windows <p> </p>"},{"location":"user_guide/install/#conda","title":"conda","text":"<p><code>conda</code>_ is a package manager and environment management system for the Anaconda / Miniconda distributions. It can be used to install Camelot from the <code>conda-forge</code> channel:</p> <pre><code>$ conda install -c conda-forge camelot-py\n</code></pre>"},{"location":"user_guide/install/#from-the-source-code","title":"From the source code","text":"<p>After installing the dependencies, you can install Camelot from source by:</p> <ol> <li> <p>Cloning the GitHub repository.</p> <pre><code>$ git clone https://www.github.com/camelot-dev/camelot\n</code></pre> </li> <li> <p>And then simply using pip again.</p> <pre><code>$ cd camelot\n$ pip install \".[base]\"\n</code></pre> </li> </ol>"},{"location":"user_guide/intro/","title":"Introduction","text":""},{"location":"user_guide/intro/#the-camelot-project","title":"The Camelot Project","text":"<p>The PDF (Portable Document Format) was born out of The Camelot Project to create \"a universal way to communicate documents across a wide variety of machine configurations, operating systems and communication networks\". The goal was to make these documents viewable on any display and printable on any modern printers. The invention of the PostScript page description language, which enabled the creation of fixed-layout flat documents (with text, fonts, graphics, images encapsulated), solved this problem.</p> <p>At a high level, PostScript defines instructions, such as \"place this character at this x,y coordinate on a plane\". Spaces can be simulated by placing characters relatively far apart. Extending from that, tables can be simulated by placing characters (which constitute words) in two-dimensional grids. A PDF viewer just takes these instructions and draws everything for the user to view. Since a PDF is just characters on a plane, there is no table data structure that can be extracted and used for analysis!</p> <p>Sadly, a lot of today's open data is trapped in PDF tables.</p>"},{"location":"user_guide/intro/#why-another-pdf-table-extraction-library","title":"Why another PDF table extraction library?","text":"<p>There are both open (Tabula, pdf-table-extract) and closed-source (smallpdf, PDFTables) tools that are widely used to extract tables from PDF files. They either give a nice output or fail miserably. There is no in between. This is not helpful since everything in the real world, including PDF table extraction, is fuzzy. This leads to the creation of ad-hoc table extraction scripts for each type of PDF table.</p> <p>Camelot was created to offer users complete control over table extraction. If you can't get your desired output with the default settings, you can tweak them and get the job done!</p> <p>Here is a comparison of Camelot's output with outputs from other open-source PDF parsing libraries and tools.</p>"},{"location":"user_guide/intro/#whats-in-a-name","title":"What's in a name?","text":"<p>As you can already guess, this library is named after The Camelot Project.</p> <p>Fun fact: In the British comedy film Monty Python and the Holy Grail (and in the Arthurian legend depicted in the film), \"Camelot\" is the name of the castle where Arthur leads his men, the Knights of the Round Table, and then sets off elsewhere after deciding that it is \"a silly place\". Interestingly, the language in which this library is written (Python) was named after Monty Python.</p>"},{"location":"user_guide/intro/#camelot-license","title":"Camelot License","text":"<pre><code>.. include:: ../../LICENSE\n</code></pre>"},{"location":"user_guide/quickstart/","title":"Quick Start","text":"<p>In a hurry to extract tables from PDFs? This document gives a good introduction to help you get started with Camelot.</p>"},{"location":"user_guide/quickstart/#read-the-pdf","title":"Read the PDF","text":"<p>Reading a PDF to extract tables with Camelot is very simple.</p> <p>Begin by importing the Camelot module::</p> <pre><code>&gt;&gt;&gt; import camelot\n</code></pre> <p>Now, let's try to read a PDF. (You can check out the PDF used in this example here) Since the PDF has a table with clearly demarcated lines, we will use the Lattice method here.</p> <p>Note</p> <p>Lattice is used by default. You can use Stream with <code>flavor='stream'</code>.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('foo.pdf')\n&gt;&gt;&gt; tables\n&lt;TableList n=1&gt;\n</code></pre> <p>Now, we have a TableList object called <code>tables</code>, which is a list of Table objects. We can get everything we need from this object.</p> <p>We can access each table using its index. From the code snippet above, we can see that the <code>tables</code> object has only one table, since <code>n=1</code>. Let's access the table using the index <code>0</code> and take a look at its <code>shape</code>.</p> <pre><code>&gt;&gt;&gt; tables[0]\n&lt;Table shape=(7, 7)&gt;\n</code></pre> <p>Let's print the parsing report.</p> <pre><code>&gt;&gt;&gt; print tables[0].parsing_report\n{\n    'accuracy': 99.02,\n    'whitespace': 12.24,\n    'order': 1,\n    'page': 1\n}\n</code></pre> <p>Woah! The accuracy is top-notch and there is less whitespace, which means the table was most likely extracted correctly. You can access the table as a pandas DataFrame by using the Table object's <code>df</code> property.</p> <pre><code>&gt;&gt;&gt; tables[0].df\n</code></pre> Cycle Name KI (1/km) Distance (mi) Percent Fuel Savings Unnamed: 4 Unnamed: 5 Unnamed: 6 nan nan nan Improved Speed Decreased Accel Eliminate Stops Decreased Idle 20122 3.3 1.3 5.9% 9.5% 29.2% 17.4% 21451 0.68 11.2 2.4% 0.1% 9.5% 2.7% 42341 0.59 58.7 8.5% 1.3% 8.5% 3.3% 20322 0.17 57.8 21.7% 0.3% 2.7% 1.2% 41711 0.07 173.9 58.1% 1.6% 2.1% 0.5% <p>Looks good! You can now export the table as a CSV file using its to_csv() method. Alternatively you can use to_json(), to_excel(), to_html(), to_markdown() or to_sqlite() methods to export the table as JSON, Excel, HTML files or a sqlite database respectively.</p> <pre><code>&gt;&gt;&gt; tables[0].to_csv('foo.csv')\n</code></pre> <p>This will export the table as a CSV file at the path specified. In this case, it is <code>foo.csv</code> in the current directory.</p> <p>You can also export all tables at once, using the TableList object's  export() method.</p> <pre><code>&gt;&gt;&gt; tables.export('foo.csv', f='csv')\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot --format csv --output foo.csv lattice foo.pdf\n</code></pre> <p>This will export all tables as CSV files at the path specified. Alternatively, you can use <code>f='json'</code>, <code>f='excel'</code>, <code>f='html'</code>, <code>f='markdown'</code> or <code>f='sqlite'</code>.</p> <p>Note</p> <p>The export() method exports files with a <code>page-*-table-*</code> suffix. In the example above, the single table in the list will be exported to <code>foo-page-1-table-1.csv</code>. If the list contains multiple tables, multiple CSV files will be created. To avoid filling up your path with multiple files, you can use <code>compress=True</code>, which will create a single ZIP file at your path with all the CSV files.</p> <p>Note</p> <p>Camelot handles rotated PDF pages automatically. As an exercise, try to extract the table out of this PDF.</p>"},{"location":"user_guide/quickstart/#specify-page-numbers","title":"Specify page numbers","text":"<p>By default, Camelot only uses the first page of the PDF to extract tables. To specify multiple pages, you can use the <code>pages</code> keyword argument::</p> <pre><code>&gt;&gt;&gt; camelot.read_pdf('your.pdf', pages='1,2,3')\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot --pages 1,2,3 lattice your.pdf\n</code></pre> <p>The <code>pages</code> keyword argument accepts pages as comma-separated string of page numbers. You can also specify page ranges \u2014 for example, <code>pages=1,4-10,20-30</code> or <code>pages=1,4-10,20-end</code>.</p>"},{"location":"user_guide/quickstart/#reading-encrypted-pdfs","title":"Reading encrypted PDFs","text":"<p>To extract tables from encrypted PDF files you must provide a password when calling read_pdf()`.</p> <pre><code>&gt;&gt;&gt; tables = camelot.read_pdf('foo.pdf', password='userpass')\n&gt;&gt;&gt; tables\n&lt;TableList n=1&gt;\n</code></pre> <p>Tip</p> <p>Here's how you can do the same with the command-line interface.</p> <pre><code>$ camelot --password userpass lattice foo.pdf\n</code></pre> <p>Camelot supports PDFs with all encryption types supported by pypdf. This might require installing PyCryptodome. An exception is thrown if the PDF cannot be read. This may be due to no password being provided, an incorrect password, or an unsupported encryption algorithm.</p> <p>Further encryption support may be added in future, however in the meantime if your PDF files are using unsupported encryption algorithms you are advised to remove encryption before calling read_pdf(). This can been successfully achieved with third-party tools such as QPDF.</p> <pre><code>$ qpdf --password=&lt;PASSWORD&gt; --decrypt input.pdf output.pdf\n</code></pre> <p>Ready for more? Check out the advanced section.</p>"}]}